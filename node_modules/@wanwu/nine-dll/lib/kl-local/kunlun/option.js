function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

import mySentry from '@wanwu/sentry';
import encryption from '@wanwu/im-encryption';
import { ua, fn } from '@wanwu/base-fn';
import { encrypt // KlSignature,
} from '@wanwu/crypto';
import { getConstID, getUUID, generateUUID } from '@wanwu/mall-web-config';
import { KL_HOSTS, KL_OS_TYPES, ERR_MSGS, AXIOS_ERR_MSGS } from './config';
import { getToken } from '@wanwu/base-sdk-token-manager';

if (!window.ENCRYPT_KEY) {
  window.ENCRYPT_KEY = {
    appVersion: ua.getAppVersion() || '3.0.2',
    // 商城
    signVersion: '1.0.0',
    // h5
    h5sId: '300100'
  };
} // 重写全局
// window.ENCRYPT_KEY.appVersion = ua.getAppVersion() || '3.0.2';


var appVer = window.ENCRYPT_KEY.appVersion;
var signVer = window.ENCRYPT_KEY.signVersion; // const KlSignatureIns = new KlSignature();

var option = {
  requestInterceptor: [/*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(config, option, source) {
      var url, data, osInfo, kl_os_type, token, kl_ver, kl_token, kl_t, kl_platform, kl_display_type, kl_os_version, kl_device_id, kl_trace_id, kl_sign_ver, kl_sdk_ver, customHeader, kl_device_token, originText, cipherText, __env, prefix, useip, useport, kl_sign, headerMapKV, headerMapKV2, headerMap, signData;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!config.withoutCancelToken) {
                config.cancelToken = source.token;
              }

              url = config.url, data = config.data;
              osInfo = 'PC';
              if (ua.isIOS()) osInfo = 'IOS';
              if (ua.isAndroid()) osInfo = 'Android';
              kl_os_type = KL_OS_TYPES[osInfo]; // 操作系统类型 android:1 ios:2 pc:3

              token = option.getToken();
              kl_ver = appVer; // 客户端版本

              kl_token = token; // 用户Token

              kl_t = parseInt(Date.now() / 1000); // 请求的时间戳，秒级别

              kl_platform = 3; // 1:app 2:小程序 3:浏览器

              if (ua.isApp()) kl_platform = 1;
              if (ua.isWechatMiniProgram()) kl_platform = 2;
              kl_display_type = 2; // 展示类型  1:Native 2:H5

              kl_os_version = '1.0.0'; // 操作系统版本

              _context.next = 17;
              return getUUID();

            case 17:
              kl_device_id = _context.sent;
              kl_trace_id = generateUUID();
              kl_sign_ver = signVer;
              kl_sdk_ver = '1.0.2'; // try {
              //     kl_device_id = await getConstID();
              // } catch(e) {
              //     console.log(e);
              // }
              // const kl_ua = ua.getUserAgent();
              // const kl_client_ip = '';
              // const signObj = {
              //     kl_path: url,
              //     kl_t: kl_t,
              // };
              // if (data) signObj.kl_data = JSON.stringify(data);
              // const signObjKey = Object.keys(signObj).sort();
              // let signStr = '';
              // signObjKey.forEach((item, index) => {
              //     if (index !== 0) signStr += '&';
              //     signStr = signStr + item + '=' + signObj[item];
              // });
              // // 生成签名
              // const kl_sign = KlSignatureIns.sign(signStr);
              // 请求网关 携带头部信息

              customHeader = {
                kl_ver: kl_ver,
                kl_token: kl_token,
                kl_t: kl_t,
                kl_os_type: kl_os_type,
                kl_platform: kl_platform,
                kl_display_type: kl_display_type,
                kl_os_version: kl_os_version,
                kl_device_id: kl_device_id,
                kl_trace_id: kl_trace_id,
                kl_sign_ver: kl_sign_ver,
                kl_sdk_ver: kl_sdk_ver // kl_sign,

              }; // 设备指纹

              kl_device_token = '';

              if (!config.fingerprint) {
                _context.next = 34;
                break;
              }

              _context.prev = 24;
              _context.next = 27;
              return getConstID();

            case 27:
              kl_device_token = _context.sent;
              _context.next = 33;
              break;

            case 30:
              _context.prev = 30;
              _context.t0 = _context["catch"](24);
              console.log(_context.t0);

            case 33:
              customHeader['kl_device_token'] = kl_device_token;

            case 34:
              // mock
              if (fn.getQueryString('__mock')) {
                customHeader['mock'] = 1;
              } // 取消上传token


              if (config.withoutToken) {
                delete customHeader['kl_token'];
                kl_token = null;
              } // 数据加密


              if (config.encrypt && typeof data !== 'undefined') {
                originText = JSON.stringify(data);
                cipherText = encrypt(originText);
                config.data = {
                  cipherText: cipherText
                };
              } // 切换host


              __env = fn.getQueryString('__env');

              if (!/^http(s)?:\/\//.test(url)) {
                if (/^api\//.test(url)) {
                  // `api/`开头
                  prefix = '/';
                } else if (/^\//.test(url)) {
                  // `/`开头
                  prefix = '';
                } else {
                  prefix = '/api/v1/mall/';
                }

                if (__env === 'useip') {
                  useip = fn.getQueryString('__useip');
                  useport = fn.getQueryString('__useport');
                  config.url = "http://".concat(useip, ":").concat(useport || 8085) + prefix + url;
                } else if (KL_HOSTS[__env]) {
                  config.url = KL_HOSTS[__env] + prefix + url;
                } else {
                  // 生产环境
                  config.url = KL_HOSTS.prod + prefix + url;
                }
              }

              config.data = option.formatData(config.data);
              kl_sign = '';
              headerMapKV = [['kl_path', url], ['kl_trace_id', kl_trace_id], ['kl_token', kl_token], ['kl_device_id', kl_device_id], ['kl_device_token', kl_device_token]];
              headerMapKV2 = [];
              headerMapKV.map(function (item) {
                if (!item[1]) {
                  delete customHeader[item[0]];
                  return;
                }

                headerMapKV2.push(item);
              });
              headerMap = new Map(headerMapKV2);

              if (config.data && config.data.kl_data) {
                signData = config.data.kl_data;
              }

              try {
                kl_sign = encryption.sign(kl_t, signData, headerMap); // console.log(signData);
              } catch (e) {
                console.log(e);
              }

              customHeader['kl_sign'] = kl_sign;
              config.headers.common = Object.assign({}, config.headers.common, customHeader);
              return _context.abrupt("return", config);

            case 50:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[24, 30]]);
    }));

    return function (_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }()],
  responseInterceptor: [function (response, option, cancel) {
    var data = response.data;
    var status = response.status;
    var formatErr = option.formatErr;
    var formatRes = option.formatRes;
    var newError = {
      type: mySentry.ERROR_TYPE.Xhr,
      level: mySentry.ERROR_LEVEL.Info,
      ConfirmReport: response.config && response.config.ConfirmReport || null
    };

    if (status !== 200 && status !== 304) {
      newError.ConfirmReport = true;
      newError.extra = response;
      newError.message = response.message || response.msg || '网络异常';
      return Promise.reject(formatErr(newError));
    }

    if (response.config.skipFilter) {
      return data;
    }

    if (data && data.success) {
      return formatRes(data);
    }

    if (data && (data.code === 301 || data.code === 302)) {
      // 未登录 或 token过期
      // skipLogin是在请求函数中作为第三个参数传递进来的
      if (!response.config.skipLogin) {
        option.cbFor401(data);
      }

      newError.payload = data;
      newError.message = '未登录'; // return new Promise((resolve, reject) => {
      //     setTimeout(() => {
      //         reject(formatErr(newError));
      //     }, 3000);
      // });

      return Promise.reject(formatErr(newError));
    }

    newError.payload = data;
    newError.message = data.message || "\u670D\u52A1\u7AEF\u5F02\u5E38\uFF1A".concat(data.code);
    return Promise.reject(formatErr(newError));
  }, function (err, option) {
    var msg = '连接服务器失败!';

    if (err && err.response && ERR_MSGS[err.response.status]) {
      msg = ERR_MSGS[err.response.status];
    }

    err.ConfirmReport = true;
    mySentry.logError(err);
    return Promise.reject(option.formatErr(_objectSpread(_objectSpread({}, err), {}, {
      message: AXIOS_ERR_MSGS[err.message] || err.message || msg
    })));
  }],
  formatRes: function formatRes(res) {
    return res.data;
  },
  formatData: function formatData(data) {
    if (data) return {
      kl_data: JSON.stringify(data)
    }; // if (data) return { kl_data: data };
  },
  getToken: getToken
};
export default option;