/**
 * @module @wanwu/canvas2image
 */

const _getDownloadImage = (url) => new Promise(resolve => {
    const img = new Image();
    if (!url) {
        resolve(null);
        return;
    } else if (url.indexOf('/') === 0) {
        url = 'https://cdn.wanwudezhi.com' + url;
    }
    if (url.indexOf('data:image') !== 0) {
        img.crossOrigin = 'Anonymous';
    }
    img.src = url;
    img.onload = () => {
        resolve(img);
    };
    img.onerror = (err) => {
        console.log(img.src);
        console.error(err);
        resolve(null);
    };
});

/**
 * Canvas2Image类（default导出兼容写法的父类，方法由这个类实现）
 * 建议使用这个类（对象类型的参数接收方式更合理）
 * @example import { Canvas2Image } from '@wanwu/canvas2image'
 * */
export class Canvas2Image {
    /**
    * 生成一个canvas2Image实例
    * @param {Object} options
    * @param {HTMLCanvasElement} options.canvas canvas元素对象
    * @param {CanvasRenderingContext2D} options.ctx canvas元素对象的ctx
    * @param {Function?} options.getDownloadImage 下载图片的方法，需要导出可供canvas直接绘制的图片方法--默认是h5下载图片方法
    * @param {Function?} options.exportImage canvas导出图片方法，默认canvas.toDataURL('image/png')
    * @param {Number} options.dpr canvas画布的dpr
    * @param {Number} options.fontSizeBase 绘制字体大小的基数
    */
    constructor({
        canvas, ctx, getDownloadImage, exportImage, dpr = 1, fontSizeBase = 1,
    }) {
        this.canvas = canvas;
        this.ctx = ctx || this.canvas.getContext('2d');
        if (typeof getDownloadImage === 'function') {
            this.getDownloadImage = getDownloadImage;
        } else {
            this.getDownloadImage = _getDownloadImage;
        }
        if (typeof exportImage === 'function') {
            this.exportImage = exportImage;
        }
        this.dpr = dpr || 1;
        this.fontSizeBase = fontSizeBase || 1;
    }

    /**
    * 设置canvas画布的dpr
    * @param {number} dpr
    */
    setDpr(dpr) {
        this.dpr = dpr;
    }

    /**
     * 设置canvas画布字体fontSize的倍数（和flexable相关）
     * @param {number} fontSizeBase
     */
    setFontSizeBase(fontSizeBase = 1) {
        this.fontSizeBase = fontSizeBase || 1;
    }

    /**
     * 获取canvas画布的宽高（去除dpr影响后的）
     * @returns {Object} {width,height}
     */
    getCanvasSize() {
        return {
            width: this.canvas.width / this.dpr,
            height: this.canvas.height / this.dpr,
        };
    }

    genFontSize(fontSize) {
        return parseInt(fontSize * (this.fontSizeBase || 1) || fontSize);
    }

    // 绘制图形框
    roundedRect(x, y, width, height, radius) {
        radius = radius || 0;
        if (width === height && (width / radius === 2)) {
            this.ctx.beginPath();
            this.ctx.arc((x + width / 2), (y + height / 2), width / 2, 0, 2 * Math.PI);
            this.ctx.closePath();
        } else {
            this.ctx.beginPath();
            this.ctx.moveTo(x, y + radius);
            this.ctx.lineTo(x, y + height - radius);
            this.ctx.quadraticCurveTo(x, y + height, x + radius, y + height);
            this.ctx.lineTo(x + width - radius, y + height);
            this.ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
            this.ctx.lineTo(x + width, y + radius);
            this.ctx.quadraticCurveTo(x + width, y, x + width - radius, y);
            this.ctx.lineTo(x + radius, y);
            this.ctx.quadraticCurveTo(x, y, x, y + radius);
            this.ctx.closePath();
        }
    }

    // 文本文案
    drawText(item, offsetX) {
        let {
            text, line = 1, lineHeight = 0, maxWidth, position, baseLine, textAlign = 'left', fontSize, color, lineThrough, padding, size, fontWeight, fontFamily,
        } = item;
        let textWidth;
        maxWidth = maxWidth || (size && size[0]);
        lineHeight = lineHeight || (size && size[1]) || 0;
        this.ctx.save();
        if (!baseLine) {
            if (!baseLine && lineHeight) {
                baseLine = 'middle';
            } else {
                baseLine = 'top';
            }
        }
        this.setTextBaseline(baseLine);
        this.setTextAlign(textAlign);
        fontSize && this.setFontSize(fontSize, fontWeight, fontFamily);
        color && this.setFillStyle(color);
        const positionTmp = [
            ...position,
        ];
        if (padding) {
            positionTmp[0] += padding;
            maxWidth -= (2 * padding);
        }
        if (offsetX) {
            positionTmp[0] += offsetX;
        }

        if (maxWidth > 0) {
            let textTmp = text;
            let leftText = '';
            for (let i = 0; i < line; i++) {
                const offsetY = i * lineHeight;
                positionTmp[1] = position[1] + offsetY + lineHeight / 2;
                if (this.ctx.measureText && this.ctx.measureText(textTmp).width > maxWidth) {
                    let suffix = '';
                    if (i === line - 1) {
                        suffix = '...';
                    }
                    while (this.ctx.measureText(textTmp + suffix).width > maxWidth) {
                        leftText = textTmp.substring(textTmp.length - 1, textTmp.length) + leftText;
                        textTmp = textTmp.substring(0, textTmp.length - 1);
                    }

                    this.ctx.fillText(textTmp + suffix, ...positionTmp);
                    textWidth = maxWidth;
                } else {
                    this.ctx.fillText(textTmp, ...positionTmp);
                    textWidth = this.ctx.measureText(text).width;
                }

                lineThrough && this.drawLineThrough(fontSize || 10, color, textTmp, positionTmp);
                textTmp = leftText;
                leftText = '';
            }
            // textWidth = maxWidth;
        } else {
            textWidth = this.ctx.measureText(text).width;
            if (lineHeight) {
                positionTmp[1] = position[1] + lineHeight / 2;
            }
            lineThrough && this.drawLineThrough(fontSize || 10, color, text, positionTmp);
            this.ctx.fillText(text, ...positionTmp);
        }
        this.ctx.restore();
        return {
            textWidth,
            offsetX: positionTmp[0],
        };
    }

    // 设置文本线
    setTextBaseline(value) {
        if (this.ctx.textBaseline) {
            this.ctx.textBaseline = value;
        } else {
            this.ctx.setTextBaseline(value);
        }
    }

    // 设置文本位置
    setTextAlign(value) {
        if (this.ctx.textAlign) {
            this.ctx.textAlign = value;
        } else {
            this.ctx.setTextAlign(value);
        }
    }

    // 设置字体大小、粗细、字体
    setFontSize(value, fontWeight, fontFamily) {
        const reFontSize = this.genFontSize(value);
        if (this.ctx.font) {
            const _fontWeight = !fontWeight ? ''
                : typeof fontWeight === 'string' ? fontWeight + ' '
                    : 'bold ';
            const __fontFamily = fontFamily ? fontFamily + ',' : '';
            this.ctx.font = `${_fontWeight}${reFontSize}px ${__fontFamily}sans-serif`;
        } else {
            this.ctx.setFontSize(reFontSize);
        }
    }

    // 设置背景色（填充色）
    setFillStyle(value) {
        if (this.ctx.fillStyle) {
            this.ctx.fillStyle = value;
        } else {
            this.ctx.setFillStyle(value);
        }
    }

    // 设置边框样式
    setStrokeStyle(value) {
        if (this.ctx.strokeStyle) {
            this.ctx.strokeStyle = value;
        } else {
            this.ctx.setStrokeStyle(value);
        }
    }

    // 设置边框宽度
    setLineWidth(value) {
        if (this.ctx.lineWidth) {
            this.ctx.lineWidth = value;
        } else {
            this.ctx.setLineWidth(value);
        }
    }

    // 设置连接线
    drawLineThrough(fontSize, color, text, position) {
        const width = this.ctx.measureText(text).width;
        const lineWidth = fontSize / 10;
        this.setStrokeStyle(color);
        this.setLineWidth(lineWidth);
        this.ctx.beginPath();
        this.ctx.moveTo(position[0], position[1]);
        this.ctx.lineTo(position[0] + width, position[1]);
        this.ctx.stroke();
    }

    // 绘制图片
    drawImage(img, item) {
        let {
            position, size, borderRadius, padding,
        } = item;
        let x = position[0] || 0;
        let y = position[1] || 0;
        let width = size[0];
        let height = size[1];
        if (padding) {
            x += padding;
            y += padding;
            width -= (2 * padding);
            height -= (2 * padding);
            borderRadius -= padding;
        }
        if (borderRadius) {
            this.ctx.save();
            this.roundedRect(x, y, width, height, borderRadius || 0);
            this.ctx.clip();
            this.ctx.drawImage(img, x, y, width, height);
            this.ctx.restore();
        } else {
            this.ctx.drawImage(img, x, y, width, height);
        }
    }

    // 绘制图形边框并填充背景色
    drawRoundedRect(item) {
        const {
            position, size, borderRadius, backgroundColor,
        } = item;
        this.ctx.save();
        this.roundedRect(...(position || [
            0,
            0,
        ]), ...size, borderRadius);
        this.setFillStyle(backgroundColor);
        this.ctx.fill();
        this.ctx.restore();
    }

    // 绘制按钮列表
    drawButtonList(item, offsetX) {
        const {
            maxWidth, position, line = 1, button, marginRight, marginBottom,
        } = item;
        const positionTmp = [
            ...position,
        ];
        positionTmp[0] = positionTmp[0] + (offsetX || 0);
        const cachePositionTmp = [...positionTmp];
        this.ctx.save();
        let nowLine = 0;
        let btnListWidth = 0;
        for (let index = 0; index < button.length; index++) {
            const buttonItem = button[index];
            let buttonWidth;
            let buttonHeight;
            if (buttonItem.size) {
                buttonWidth = buttonItem.size[0];
                buttonHeight = buttonItem.size[1];
            } else if (buttonItem.text) {
                buttonItem.position = [
                    positionTmp[0] + this.getCanvasSize().width + 9999,
                    positionTmp[1] + this.getCanvasSize().height + 9999,
                ];
                const textObj = this.drawText(buttonItem);
                if (item.maxWidth && item.maxWidth > textObj.textWidth) {
                    buttonWidth = Math.round(textObj.textWidth);
                } else {
                    buttonWidth = buttonItem.maxWidth;
                }

                if (buttonItem.padding) {
                    buttonWidth += 2 * buttonItem.padding;
                }
                if (buttonItem.lineHeight) {
                    buttonHeight = buttonItem.lineHeight;
                }
            }
            buttonItem.size = [
                buttonWidth,
                buttonHeight,
            ];
            const allWidth = positionTmp[0] + buttonWidth;
            if (index === 0) {
                buttonItem.position = [...positionTmp];
                this.drawButton(buttonItem);
                positionTmp[0] = allWidth + marginRight;
            } else if (maxWidth > 0) {
                if (maxWidth > allWidth) {
                    buttonItem.position = positionTmp;
                    this.drawButton(buttonItem);
                    positionTmp[0] = allWidth + marginRight;
                } else {
                    if (nowLine <= line) {
                        buttonItem.position = positionTmp;
                        this.drawButton(buttonItem);
                        positionTmp[0] = cachePositionTmp[0];
                        positionTmp[1] = positionTmp[1] + buttonHeight + marginBottom;
                        nowLine++;
                    } else {
                        return;
                    }
                }
            } else {
                buttonItem.position = positionTmp;
                this.drawButton(buttonItem);
                positionTmp[0] = allWidth + marginRight;
            }
            btnListWidth += buttonItem.size[0] + marginRight;
        }
        if (nowLine > 0) {
            btnListWidth = maxWidth;
        }
        return {
            offsetX: position[0] + (offsetX || 0),
            allWidth: btnListWidth,
        };
    }

    // 绘制单个按钮
    drawButton(item) {
        if (item.backgroundColor) {
            this.drawRoundedRect(item);
        }
        if (item.text) {
            this.drawText(item);
        }
    }

    drawTextArr(item, positionX) {
        let cache;
        const {
            textList,
        } = item;
        if (positionX) {
            const newTextList = [
                {
                    text: '',
                    position: [
                        positionX,
                        0,
                    ],
                },
                ...textList,
            ];
            return this.drawTextArr({
                textList: newTextList,
            });
        }
        textList.forEach(tItem => {
            if (tItem.backgroundColor) {
                this.drawRoundedRect(tItem);
            }
            if (tItem.text || tItem.text === '') {
                cache = this.drawText(tItem, cache && (cache.textWidth || 0) + (cache.offsetX || 0));
            }
        });
        return cache;
    }

    drawTextList(item, offsetX) {
        let {
            textAlign = 'left',
            textList,
            positionX,
        } = item;
        positionX = (offsetX || 0) + positionX;
        if (textAlign !== 'left') {
            const cacheOffsetX = this.getCanvasSize().width + 9999;
            const newTextList = [
                {
                    text: '',
                    position: [
                        cacheOffsetX,
                        0,
                    ],
                },
                ...textList,
            ];
            const cache = this.drawTextArr({
                textList: newTextList,
            });
            const allWidth = (cache.textWidth || 0) + (cache.offsetX || 0) - cacheOffsetX;
            if (textAlign === 'center') {
                const isPositionXNumber = typeof positionX === 'number';
                const offsetX = (isPositionXNumber ? positionX : parseInt(this.getCanvasSize().width / 2)) - parseInt(allWidth / 2);
                return this.drawTextArr(item, offsetX);
            } else if (textAlign === 'right') {
                const offsetX = positionX || this.getCanvasSize().width - allWidth;
                return this.drawTextArr(item, offsetX);
            }
        } else {
            return this.drawTextArr(item, positionX);
        }
    }

    drawList(item) {
        const {
            textAlign = 'left',
            list,
            positionX,
        } = item;
        let allWidth = 0;
        const tasks = list.map((item) => {
            return this.getDownloadImage(item.image);
        });
        if (textAlign !== 'left') {
            const cacheOffsetX = this.getCanvasSize().width + 9999;
            // Promise.all(tasks).then(images => {
            list.forEach((config, index) => {
                if (config.backgroundColor) {
                    // this.drawRoundedRect(config);
                    allWidth += ((config.size[0] || 0) + (config.position[0] || 0));
                } else if (config.image) {
                    allWidth += ((config.size[0] || 0) + (config.position[0] || 0));
                    // this.drawImage(images[index], config);
                } else if (config.button) {
                    const cache = this.drawButtonList(config, cacheOffsetX);
                    allWidth += ((cache.allWidth || 0) + (config.position[0] || 0));
                } else if (config.text) {
                    const cache = this.drawText(config, cacheOffsetX);
                    allWidth += ((cache.textWidth || 0) + (config.position[0] || 0));
                } else if (config.textList) {
                    const cache = this.drawTextList(config, cacheOffsetX);
                    allWidth += ((cache.textWidth || 0) + (config.position[0] || 0));
                }
            });
        }
        return Promise.all(tasks).then(images => {
            // const offsetX = positionX || 0;
            let offsetX = positionX || 0;
            if (textAlign === 'center') {
                offsetX = positionX || parseInt(this.getCanvasSize().width / 2) - parseInt(allWidth / 2);
            } else if (textAlign === 'right') {
                offsetX = positionX || this.getCanvasSize().width - allWidth;
            }
            list.forEach((config, index) => {
                if (config.backgroundColor || images[index]) {
                    config.position[0] += offsetX;
                    if (config.backgroundColor) {
                        this.drawRoundedRect(config);
                    }
                    if (images[index]) {
                        this.drawImage(images[index], config);
                    }
                    if (config.text) {
                        this.drawText(config);
                    }
                    offsetX = ((config.size[0] || 0) + (config.position[0] || 0));
                } else if (config.button) {
                    const cache = this.drawButtonList(config, offsetX);
                    offsetX += ((cache.allWidth || 0) + (config.position[0] || 0));
                } else if (config.text) {
                    const cache = this.drawText(config, offsetX);
                    offsetX += ((cache.textWidth || 0) + (config.position[0]));
                } else if (config.textList) {
                    const cache = this.drawTextList(config, offsetX);
                    offsetX += ((cache.textWidth || 0) + (config.position[0]));
                }
            });
        });
    }

    /**
     * 根据canvasConfig绘制图片并导出base64
     * @param {Object} canvasConfig
     * @returns {Promise<string>} 返回图片base64字符串（如果new class时传入了exportImage，则返回exportImage对应的返回值)
     */
    draw(canvasConfig) {
        // return new Promise((resolve, reject) => {
        // 获取图片集合，返回Promise对象
        const tasks = canvasConfig.map((item) => {
            return this.getDownloadImage(item.image);
        });

        return Promise.all(tasks).then(async (images) => {
            const foo = async () => {
                for (let i = 0; i < canvasConfig.length; i++) {
                    const config = canvasConfig[i];
                    const index = i;
                    if (config instanceof Array) {
                        let cache;
                        config.forEach(item => {
                            if (item.backgroundColor) {
                                this.drawRoundedRect(item);
                            }
                            if (item.text) {
                                cache = this.drawText(item, cache && (cache.textWidth || 0) + (cache.offsetX || 0));
                            }
                        });
                    } else {
                        if (config.backgroundColor) {
                            this.drawRoundedRect(config);
                        }
                        if (images[index]) {
                            this.drawImage(images[index], config);
                        }
                        if (config.text) {
                            this.drawText(config);
                        }
                        if (config.button) {
                            this.drawButtonList(config);
                        }
                        if (config.textList) {
                            this.drawTextList(config);
                        }
                        if (config.list) {
                            await this.drawList(config);
                        }
                    }
                }
            };
            await foo();
            // 将整个canvas对象转换为图片的url
            this.base64Url = this.exportImage ? await this.exportImage(this.canvas) : this.canvas.toDataURL('image/png');
            return this.base64Url;
        }).catch((error) => {
            console.log(error);
            return Promise.reject(error);
        });
    }
}


export {
    /**
     * 获取下载图片
     * @param {string} url 图片地址
     * @returns {Promise<HTMLImageElement>} img对象实例
     */
    _getDownloadImage as getDownloadImage,
};


/** 兼容老写法，不建议使用（参数列表过长了，新类接收对象类型的参数，更好用） */
export default class OldCanvas2Image extends Canvas2Image {
    /**
    * 生成一个canvas2Image实例
    * @param {HTMLCanvasElement} canvas canvas元素对象
    * @param {CanvasRenderingContext2D} ctx canvas元素对象的ctx
    * @param {Function?} getDownloadImage 下载图片的方法，需要导出可供canvas直接绘制的图片方法--默认是h5下载图片方法
    * @param {Function?} exportImage canvas导出图片方法，默认canvas.toDataURL('image/png')
    * @param {Number} dpr canvas画布的dpr
    * @param {Number} fontSizeBase 绘制字体大小的基数
    */
    constructor(canvas, ctx, getDownloadImage, exportImage, dpr, fontSizeBase) {
        super({
            canvas,
            ctx,
            getDownloadImage,
            exportImage,
            dpr,
            fontSizeBase,
        });
    }
}


/**
* 根据canvas2image配置导出base64字符串
* @param {Opject} config canvas画图配置
* @param {number} config.width canvas画布宽度
* @param {number} config.height canvas画布高度
* @param {Array<Object>} config.canvasConfig canvas2Image画图配置
* @param {Opject?} options canvas2Image配置
* @param {Function?} options.exportImage canvas导出图片方法，默认canvas.toDataURL('image/png')
* @param {Number} options.dpr canvas画布的dpr
* @param {Number} options.fontSizeBase 绘制字体大小的基数
* @returns {Promise<string>} base64字符串
*/
export function drawImage({
    width, height, canvasConfig,
}, {
    exportImage, dpr = 3,
} = {}) {
    const canvas = document.createElement('canvas');
    // 因为目前手机最高dpr大概是3，所以dpr=3是一个可以保证图片效果的值
    // 设定 canvas 元素属性宽高为 DOM 节点宽高 * 像素比
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    // 设定 canvas css宽高为 DOM 节点宽高
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    // 获取画笔
    const ctx = canvas.getContext('2d');
    // 将所有绘制内容放大像素比倍
    dpr !== 1 && ctx.scale(dpr, dpr);
    const doc = window.document;
    const docEl = doc.documentElement;
    const rem = docEl.getAttribute('data-rem');
    const computedRem = docEl.getAttribute('data-computed-rem');
    // 根据flexable的rem和computedRem算出来fontSizeBase，确保图片在修改了系统字体大小的手机上显示正常
    const fontSizeBase = (computedRem / rem) || 1;
    // 具名导出使用options参数，更好用，default导出的class参数列表太长了不建议使用
    const canvas2Image = new Canvas2Image({
        canvas,
        ctx,
        dpr,
        fontSizeBase,
        exportImage,
    });
    return canvas2Image.draw(canvasConfig).then(res => {
        return res;
    }).catch(err => {
        return Promise.reject(err);
    });
}
