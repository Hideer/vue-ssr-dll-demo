import 'core-js/modules/es.array.concat';
import 'core-js/modules/es.array.fill';
import 'core-js/modules/es.array.for-each';
import 'core-js/modules/es.array.index-of';
import 'core-js/modules/es.array.iterator';
import 'core-js/modules/es.array.map';
import 'core-js/modules/es.date.to-string';
import 'core-js/modules/es.object.to-string';
import 'core-js/modules/es.parse-int';
import 'core-js/modules/es.promise';
import 'core-js/modules/es.reflect.construct';
import 'core-js/modules/es.regexp.to-string';
import 'core-js/modules/es.string.iterator';
import 'core-js/modules/web.dom-collections.for-each';
import 'core-js/modules/web.dom-collections.iterator';
import _inherits from '@babel/runtime/helpers/esm/inherits';
import _possibleConstructorReturn from '@babel/runtime/helpers/esm/possibleConstructorReturn';
import _getPrototypeOf from '@babel/runtime/helpers/esm/getPrototypeOf';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import 'regenerator-runtime/runtime';
import _asyncToGenerator from '@babel/runtime/helpers/esm/asyncToGenerator';
import _toConsumableArray from '@babel/runtime/helpers/esm/toConsumableArray';
import _classCallCheck from '@babel/runtime/helpers/esm/classCallCheck';
import _createClass from '@babel/runtime/helpers/esm/createClass';

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * @module @wanwu/canvas2image
 */
var _getDownloadImage = function _getDownloadImage(url) {
  return new Promise(function (resolve) {
    var img = new Image();

    if (!url) {
      resolve(null);
      return;
    } else if (url.indexOf('/') === 0) {
      url = 'https://cdn.wanwudezhi.com' + url;
    }

    if (url.indexOf('data:image') !== 0) {
      img.crossOrigin = 'Anonymous';
    }

    img.src = url;

    img.onload = function () {
      resolve(img);
    };

    img.onerror = function (err) {
      console.log(img.src);
      console.error(err);
      resolve(null);
    };
  });
};
/**
 * Canvas2Image类（default导出兼容写法的父类，方法由这个类实现）
 * 建议使用这个类（对象类型的参数接收方式更合理）
 * @example import { Canvas2Image } from '@wanwu/canvas2image'
 * */


var Canvas2Image = /*#__PURE__*/function () {
  /**
  * 生成一个canvas2Image实例
  * @param {Object} options
  * @param {HTMLCanvasElement} options.canvas canvas元素对象
  * @param {CanvasRenderingContext2D} options.ctx canvas元素对象的ctx
  * @param {Function?} options.getDownloadImage 下载图片的方法，需要导出可供canvas直接绘制的图片方法--默认是h5下载图片方法
  * @param {Function?} options.exportImage canvas导出图片方法，默认canvas.toDataURL('image/png')
  * @param {Number} options.dpr canvas画布的dpr
  * @param {Number} options.fontSizeBase 绘制字体大小的基数
  */
  function Canvas2Image(_ref) {
    var canvas = _ref.canvas,
        ctx = _ref.ctx,
        getDownloadImage = _ref.getDownloadImage,
        exportImage = _ref.exportImage,
        _ref$dpr = _ref.dpr,
        dpr = _ref$dpr === void 0 ? 1 : _ref$dpr,
        _ref$fontSizeBase = _ref.fontSizeBase,
        fontSizeBase = _ref$fontSizeBase === void 0 ? 1 : _ref$fontSizeBase;

    _classCallCheck(this, Canvas2Image);

    this.canvas = canvas;
    this.ctx = ctx || this.canvas.getContext('2d');

    if (typeof getDownloadImage === 'function') {
      this.getDownloadImage = getDownloadImage;
    } else {
      this.getDownloadImage = _getDownloadImage;
    }

    if (typeof exportImage === 'function') {
      this.exportImage = exportImage;
    }

    this.dpr = dpr || 1;
    this.fontSizeBase = fontSizeBase || 1;
  }
  /**
  * 设置canvas画布的dpr
  * @param {number} dpr
  */


  _createClass(Canvas2Image, [{
    key: "setDpr",
    value: function setDpr(dpr) {
      this.dpr = dpr;
    }
    /**
     * 设置canvas画布字体fontSize的倍数（和flexable相关）
     * @param {number} fontSizeBase
     */

  }, {
    key: "setFontSizeBase",
    value: function setFontSizeBase() {
      var fontSizeBase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      this.fontSizeBase = fontSizeBase || 1;
    }
    /**
     * 获取canvas画布的宽高（去除dpr影响后的）
     * @returns {Object} {width,height}
     */

  }, {
    key: "getCanvasSize",
    value: function getCanvasSize() {
      return {
        width: this.canvas.width / this.dpr,
        height: this.canvas.height / this.dpr
      };
    }
  }, {
    key: "genFontSize",
    value: function genFontSize(fontSize) {
      return parseInt(fontSize * (this.fontSizeBase || 1) || fontSize);
    } // 绘制图形框

  }, {
    key: "roundedRect",
    value: function roundedRect(x, y, width, height, radius) {
      radius = radius || 0;

      if (width === height && width / radius === 2) {
        this.ctx.beginPath();
        this.ctx.arc(x + width / 2, y + height / 2, width / 2, 0, 2 * Math.PI);
        this.ctx.closePath();
      } else {
        this.ctx.beginPath();
        this.ctx.moveTo(x, y + radius);
        this.ctx.lineTo(x, y + height - radius);
        this.ctx.quadraticCurveTo(x, y + height, x + radius, y + height);
        this.ctx.lineTo(x + width - radius, y + height);
        this.ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
        this.ctx.lineTo(x + width, y + radius);
        this.ctx.quadraticCurveTo(x + width, y, x + width - radius, y);
        this.ctx.lineTo(x + radius, y);
        this.ctx.quadraticCurveTo(x, y, x, y + radius);
        this.ctx.closePath();
      }
    } // 文本文案

  }, {
    key: "drawText",
    value: function drawText(item, offsetX) {
      var text = item.text,
          _item$line = item.line,
          line = _item$line === void 0 ? 1 : _item$line,
          _item$lineHeight = item.lineHeight,
          lineHeight = _item$lineHeight === void 0 ? 0 : _item$lineHeight,
          maxWidth = item.maxWidth,
          position = item.position,
          baseLine = item.baseLine,
          _item$textAlign = item.textAlign,
          textAlign = _item$textAlign === void 0 ? 'left' : _item$textAlign,
          fontSize = item.fontSize,
          color = item.color,
          lineThrough = item.lineThrough,
          padding = item.padding,
          size = item.size,
          fontWeight = item.fontWeight,
          fontFamily = item.fontFamily;
      var textWidth;
      maxWidth = maxWidth || size && size[0];
      lineHeight = lineHeight || size && size[1] || 0;
      this.ctx.save();

      if (!baseLine) {
        if (!baseLine && lineHeight) {
          baseLine = 'middle';
        } else {
          baseLine = 'top';
        }
      }

      this.setTextBaseline(baseLine);
      this.setTextAlign(textAlign);
      fontSize && this.setFontSize(fontSize, fontWeight, fontFamily);
      color && this.setFillStyle(color);

      var positionTmp = _toConsumableArray(position);

      if (padding) {
        positionTmp[0] += padding;
        maxWidth -= 2 * padding;
      }

      if (offsetX) {
        positionTmp[0] += offsetX;
      }

      if (maxWidth > 0) {
        var textTmp = text;
        var leftText = '';

        for (var i = 0; i < line; i++) {
          var offsetY = i * lineHeight;
          positionTmp[1] = position[1] + offsetY + lineHeight / 2;

          if (this.ctx.measureText && this.ctx.measureText(textTmp).width > maxWidth) {
            var _this$ctx;

            var suffix = '';

            if (i === line - 1) {
              suffix = '...';
            }

            while (this.ctx.measureText(textTmp + suffix).width > maxWidth) {
              leftText = textTmp.substring(textTmp.length - 1, textTmp.length) + leftText;
              textTmp = textTmp.substring(0, textTmp.length - 1);
            }

            (_this$ctx = this.ctx).fillText.apply(_this$ctx, [textTmp + suffix].concat(_toConsumableArray(positionTmp)));

            textWidth = maxWidth;
          } else {
            var _this$ctx2;

            (_this$ctx2 = this.ctx).fillText.apply(_this$ctx2, [textTmp].concat(_toConsumableArray(positionTmp)));

            textWidth = this.ctx.measureText(text).width;
          }

          lineThrough && this.drawLineThrough(fontSize || 10, color, textTmp, positionTmp);
          textTmp = leftText;
          leftText = '';
        } // textWidth = maxWidth;

      } else {
        var _this$ctx3;

        textWidth = this.ctx.measureText(text).width;

        if (lineHeight) {
          positionTmp[1] = position[1] + lineHeight / 2;
        }

        lineThrough && this.drawLineThrough(fontSize || 10, color, text, positionTmp);

        (_this$ctx3 = this.ctx).fillText.apply(_this$ctx3, [text].concat(_toConsumableArray(positionTmp)));
      }

      this.ctx.restore();
      return {
        textWidth: textWidth,
        offsetX: positionTmp[0]
      };
    } // 设置文本线

  }, {
    key: "setTextBaseline",
    value: function setTextBaseline(value) {
      if (this.ctx.textBaseline) {
        this.ctx.textBaseline = value;
      } else {
        this.ctx.setTextBaseline(value);
      }
    } // 设置文本位置

  }, {
    key: "setTextAlign",
    value: function setTextAlign(value) {
      if (this.ctx.textAlign) {
        this.ctx.textAlign = value;
      } else {
        this.ctx.setTextAlign(value);
      }
    } // 设置字体大小、粗细、字体

  }, {
    key: "setFontSize",
    value: function setFontSize(value, fontWeight, fontFamily) {
      var reFontSize = this.genFontSize(value);

      if (this.ctx.font) {
        var _fontWeight = !fontWeight ? '' : typeof fontWeight === 'string' ? fontWeight + ' ' : 'bold ';

        var __fontFamily = fontFamily ? fontFamily + ',' : '';

        this.ctx.font = "".concat(_fontWeight).concat(reFontSize, "px ").concat(__fontFamily, "sans-serif");
      } else {
        this.ctx.setFontSize(reFontSize);
      }
    } // 设置背景色（填充色）

  }, {
    key: "setFillStyle",
    value: function setFillStyle(value) {
      if (this.ctx.fillStyle) {
        this.ctx.fillStyle = value;
      } else {
        this.ctx.setFillStyle(value);
      }
    } // 设置边框样式

  }, {
    key: "setStrokeStyle",
    value: function setStrokeStyle(value) {
      if (this.ctx.strokeStyle) {
        this.ctx.strokeStyle = value;
      } else {
        this.ctx.setStrokeStyle(value);
      }
    } // 设置边框宽度

  }, {
    key: "setLineWidth",
    value: function setLineWidth(value) {
      if (this.ctx.lineWidth) {
        this.ctx.lineWidth = value;
      } else {
        this.ctx.setLineWidth(value);
      }
    } // 设置连接线

  }, {
    key: "drawLineThrough",
    value: function drawLineThrough(fontSize, color, text, position) {
      var width = this.ctx.measureText(text).width;
      var lineWidth = fontSize / 10;
      this.setStrokeStyle(color);
      this.setLineWidth(lineWidth);
      this.ctx.beginPath();
      this.ctx.moveTo(position[0], position[1]);
      this.ctx.lineTo(position[0] + width, position[1]);
      this.ctx.stroke();
    } // 绘制图片

  }, {
    key: "drawImage",
    value: function drawImage(img, item) {
      var position = item.position,
          size = item.size,
          borderRadius = item.borderRadius,
          padding = item.padding;
      var x = position[0] || 0;
      var y = position[1] || 0;
      var width = size[0];
      var height = size[1];

      if (padding) {
        x += padding;
        y += padding;
        width -= 2 * padding;
        height -= 2 * padding;
        borderRadius -= padding;
      }

      if (borderRadius) {
        this.ctx.save();
        this.roundedRect(x, y, width, height, borderRadius || 0);
        this.ctx.clip();
        this.ctx.drawImage(img, x, y, width, height);
        this.ctx.restore();
      } else {
        this.ctx.drawImage(img, x, y, width, height);
      }
    } // 绘制图形边框并填充背景色

  }, {
    key: "drawRoundedRect",
    value: function drawRoundedRect(item) {
      var position = item.position,
          size = item.size,
          borderRadius = item.borderRadius,
          backgroundColor = item.backgroundColor;
      this.ctx.save();
      this.roundedRect.apply(this, _toConsumableArray(position || [0, 0]).concat(_toConsumableArray(size), [borderRadius]));
      this.setFillStyle(backgroundColor);
      this.ctx.fill();
      this.ctx.restore();
    } // 绘制按钮列表

  }, {
    key: "drawButtonList",
    value: function drawButtonList(item, offsetX) {
      var maxWidth = item.maxWidth,
          position = item.position,
          _item$line2 = item.line,
          line = _item$line2 === void 0 ? 1 : _item$line2,
          button = item.button,
          marginRight = item.marginRight,
          marginBottom = item.marginBottom;

      var positionTmp = _toConsumableArray(position);

      positionTmp[0] = positionTmp[0] + (offsetX || 0);

      var cachePositionTmp = _toConsumableArray(positionTmp);

      this.ctx.save();
      var nowLine = 0;
      var btnListWidth = 0;

      for (var index = 0; index < button.length; index++) {
        var buttonItem = button[index];
        var buttonWidth = void 0;
        var buttonHeight = void 0;

        if (buttonItem.size) {
          buttonWidth = buttonItem.size[0];
          buttonHeight = buttonItem.size[1];
        } else if (buttonItem.text) {
          buttonItem.position = [positionTmp[0] + this.getCanvasSize().width + 9999, positionTmp[1] + this.getCanvasSize().height + 9999];
          var textObj = this.drawText(buttonItem);

          if (item.maxWidth && item.maxWidth > textObj.textWidth) {
            buttonWidth = Math.round(textObj.textWidth);
          } else {
            buttonWidth = buttonItem.maxWidth;
          }

          if (buttonItem.padding) {
            buttonWidth += 2 * buttonItem.padding;
          }

          if (buttonItem.lineHeight) {
            buttonHeight = buttonItem.lineHeight;
          }
        }

        buttonItem.size = [buttonWidth, buttonHeight];
        var allWidth = positionTmp[0] + buttonWidth;

        if (index === 0) {
          buttonItem.position = _toConsumableArray(positionTmp);
          this.drawButton(buttonItem);
          positionTmp[0] = allWidth + marginRight;
        } else if (maxWidth > 0) {
          if (maxWidth > allWidth) {
            buttonItem.position = positionTmp;
            this.drawButton(buttonItem);
            positionTmp[0] = allWidth + marginRight;
          } else {
            if (nowLine <= line) {
              buttonItem.position = positionTmp;
              this.drawButton(buttonItem);
              positionTmp[0] = cachePositionTmp[0];
              positionTmp[1] = positionTmp[1] + buttonHeight + marginBottom;
              nowLine++;
            } else {
              return;
            }
          }
        } else {
          buttonItem.position = positionTmp;
          this.drawButton(buttonItem);
          positionTmp[0] = allWidth + marginRight;
        }

        btnListWidth += buttonItem.size[0] + marginRight;
      }

      if (nowLine > 0) {
        btnListWidth = maxWidth;
      }

      return {
        offsetX: position[0] + (offsetX || 0),
        allWidth: btnListWidth
      };
    } // 绘制单个按钮

  }, {
    key: "drawButton",
    value: function drawButton(item) {
      if (item.backgroundColor) {
        this.drawRoundedRect(item);
      }

      if (item.text) {
        this.drawText(item);
      }
    }
  }, {
    key: "drawTextArr",
    value: function drawTextArr(item, positionX) {
      var _this = this;

      var cache;
      var textList = item.textList;

      if (positionX) {
        var newTextList = [{
          text: '',
          position: [positionX, 0]
        }].concat(_toConsumableArray(textList));
        return this.drawTextArr({
          textList: newTextList
        });
      }

      textList.forEach(function (tItem) {
        if (tItem.backgroundColor) {
          _this.drawRoundedRect(tItem);
        }

        if (tItem.text || tItem.text === '') {
          cache = _this.drawText(tItem, cache && (cache.textWidth || 0) + (cache.offsetX || 0));
        }
      });
      return cache;
    }
  }, {
    key: "drawTextList",
    value: function drawTextList(item, offsetX) {
      var _item$textAlign2 = item.textAlign,
          textAlign = _item$textAlign2 === void 0 ? 'left' : _item$textAlign2,
          textList = item.textList,
          positionX = item.positionX;
      positionX = (offsetX || 0) + positionX;

      if (textAlign !== 'left') {
        var cacheOffsetX = this.getCanvasSize().width + 9999;
        var newTextList = [{
          text: '',
          position: [cacheOffsetX, 0]
        }].concat(_toConsumableArray(textList));
        var cache = this.drawTextArr({
          textList: newTextList
        });
        var allWidth = (cache.textWidth || 0) + (cache.offsetX || 0) - cacheOffsetX;

        if (textAlign === 'center') {
          var isPositionXNumber = typeof positionX === 'number';

          var _offsetX = (isPositionXNumber ? positionX : parseInt(this.getCanvasSize().width / 2)) - parseInt(allWidth / 2);

          return this.drawTextArr(item, _offsetX);
        } else if (textAlign === 'right') {
          var _offsetX2 = positionX || this.getCanvasSize().width - allWidth;

          return this.drawTextArr(item, _offsetX2);
        }
      } else {
        return this.drawTextArr(item, positionX);
      }
    }
  }, {
    key: "drawList",
    value: function drawList(item) {
      var _this2 = this;

      var _item$textAlign3 = item.textAlign,
          textAlign = _item$textAlign3 === void 0 ? 'left' : _item$textAlign3,
          list = item.list,
          positionX = item.positionX;
      var allWidth = 0;
      var tasks = list.map(function (item) {
        return _this2.getDownloadImage(item.image);
      });

      if (textAlign !== 'left') {
        var cacheOffsetX = this.getCanvasSize().width + 9999; // Promise.all(tasks).then(images => {

        list.forEach(function (config, index) {
          if (config.backgroundColor) {
            // this.drawRoundedRect(config);
            allWidth += (config.size[0] || 0) + (config.position[0] || 0);
          } else if (config.image) {
            allWidth += (config.size[0] || 0) + (config.position[0] || 0); // this.drawImage(images[index], config);
          } else if (config.button) {
            var cache = _this2.drawButtonList(config, cacheOffsetX);

            allWidth += (cache.allWidth || 0) + (config.position[0] || 0);
          } else if (config.text) {
            var _cache = _this2.drawText(config, cacheOffsetX);

            allWidth += (_cache.textWidth || 0) + (config.position[0] || 0);
          } else if (config.textList) {
            var _cache2 = _this2.drawTextList(config, cacheOffsetX);

            allWidth += (_cache2.textWidth || 0) + (config.position[0] || 0);
          }
        });
      }

      return Promise.all(tasks).then(function (images) {
        // const offsetX = positionX || 0;
        var offsetX = positionX || 0;

        if (textAlign === 'center') {
          offsetX = positionX || parseInt(_this2.getCanvasSize().width / 2) - parseInt(allWidth / 2);
        } else if (textAlign === 'right') {
          offsetX = positionX || _this2.getCanvasSize().width - allWidth;
        }

        list.forEach(function (config, index) {
          if (config.backgroundColor || images[index]) {
            config.position[0] += offsetX;

            if (config.backgroundColor) {
              _this2.drawRoundedRect(config);
            }

            if (images[index]) {
              _this2.drawImage(images[index], config);
            }

            if (config.text) {
              _this2.drawText(config);
            }

            offsetX = (config.size[0] || 0) + (config.position[0] || 0);
          } else if (config.button) {
            var cache = _this2.drawButtonList(config, offsetX);

            offsetX += (cache.allWidth || 0) + (config.position[0] || 0);
          } else if (config.text) {
            var _cache3 = _this2.drawText(config, offsetX);

            offsetX += (_cache3.textWidth || 0) + config.position[0];
          } else if (config.textList) {
            var _cache4 = _this2.drawTextList(config, offsetX);

            offsetX += (_cache4.textWidth || 0) + config.position[0];
          }
        });
      });
    }
    /**
     * 根据canvasConfig绘制图片并导出base64
     * @param {Object} canvasConfig
     * @returns {Promise<string>} 返回图片base64字符串（如果new class时传入了exportImage，则返回exportImage对应的返回值)
     */

  }, {
    key: "draw",
    value: function draw(canvasConfig) {
      var _this3 = this;

      // return new Promise((resolve, reject) => {
      // 获取图片集合，返回Promise对象
      var tasks = canvasConfig.map(function (item) {
        return _this3.getDownloadImage(item.image);
      });
      return Promise.all(tasks).then( /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(images) {
          var foo;
          return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  foo = /*#__PURE__*/function () {
                    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
                      var i, config, index;
                      return _regeneratorRuntime.wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              i = 0;

                            case 1:
                              if (!(i < canvasConfig.length)) {
                                _context.next = 19;
                                break;
                              }

                              config = canvasConfig[i];
                              index = i;

                              if (!(config instanceof Array)) {
                                _context.next = 8;
                                break;
                              }

                              (function () {
                                var cache = void 0;
                                config.forEach(function (item) {
                                  if (item.backgroundColor) {
                                    _this3.drawRoundedRect(item);
                                  }

                                  if (item.text) {
                                    cache = _this3.drawText(item, cache && (cache.textWidth || 0) + (cache.offsetX || 0));
                                  }
                                });
                              })();

                              _context.next = 16;
                              break;

                            case 8:
                              if (config.backgroundColor) {
                                _this3.drawRoundedRect(config);
                              }

                              if (images[index]) {
                                _this3.drawImage(images[index], config);
                              }

                              if (config.text) {
                                _this3.drawText(config);
                              }

                              if (config.button) {
                                _this3.drawButtonList(config);
                              }

                              if (config.textList) {
                                _this3.drawTextList(config);
                              }

                              if (!config.list) {
                                _context.next = 16;
                                break;
                              }

                              _context.next = 16;
                              return _this3.drawList(config);

                            case 16:
                              i++;
                              _context.next = 1;
                              break;

                            case 19:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee);
                    }));

                    return function foo() {
                      return _ref3.apply(this, arguments);
                    };
                  }();

                  _context2.next = 3;
                  return foo();

                case 3:
                  if (!_this3.exportImage) {
                    _context2.next = 9;
                    break;
                  }

                  _context2.next = 6;
                  return _this3.exportImage(_this3.canvas);

                case 6:
                  _context2.t0 = _context2.sent;
                  _context2.next = 10;
                  break;

                case 9:
                  _context2.t0 = _this3.canvas.toDataURL('image/png');

                case 10:
                  _this3.base64Url = _context2.t0;
                  return _context2.abrupt("return", _this3.base64Url);

                case 12:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function (_x) {
          return _ref2.apply(this, arguments);
        };
      }())["catch"](function (error) {
        console.log(error);
        return Promise.reject(error);
      });
    }
  }]);

  return Canvas2Image;
}();
/** 兼容老写法，不建议使用（参数列表过长了，新类接收对象类型的参数，更好用） */

var OldCanvas2Image = /*#__PURE__*/function (_Canvas2Image) {
  _inherits(OldCanvas2Image, _Canvas2Image);

  var _super = _createSuper(OldCanvas2Image);

  /**
  * 生成一个canvas2Image实例
  * @param {HTMLCanvasElement} canvas canvas元素对象
  * @param {CanvasRenderingContext2D} ctx canvas元素对象的ctx
  * @param {Function?} getDownloadImage 下载图片的方法，需要导出可供canvas直接绘制的图片方法--默认是h5下载图片方法
  * @param {Function?} exportImage canvas导出图片方法，默认canvas.toDataURL('image/png')
  * @param {Number} dpr canvas画布的dpr
  * @param {Number} fontSizeBase 绘制字体大小的基数
  */
  function OldCanvas2Image(canvas, ctx, getDownloadImage, exportImage, dpr, fontSizeBase) {
    _classCallCheck(this, OldCanvas2Image);

    return _super.call(this, {
      canvas: canvas,
      ctx: ctx,
      getDownloadImage: getDownloadImage,
      exportImage: exportImage,
      dpr: dpr,
      fontSizeBase: fontSizeBase
    });
  }

  return OldCanvas2Image;
}(Canvas2Image);
function drawImage(_ref4) {
  var width = _ref4.width,
      height = _ref4.height,
      canvasConfig = _ref4.canvasConfig;

  var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      exportImage = _ref5.exportImage,
      _ref5$dpr = _ref5.dpr,
      dpr = _ref5$dpr === void 0 ? 3 : _ref5$dpr;

  var canvas = document.createElement('canvas'); // 因为目前手机最高dpr大概是3，所以dpr=3是一个可以保证图片效果的值
  // 设定 canvas 元素属性宽高为 DOM 节点宽高 * 像素比

  canvas.width = width * dpr;
  canvas.height = height * dpr; // 设定 canvas css宽高为 DOM 节点宽高

  canvas.style.width = "".concat(width, "px");
  canvas.style.height = "".concat(height, "px"); // 获取画笔

  var ctx = canvas.getContext('2d'); // 将所有绘制内容放大像素比倍

  dpr !== 1 && ctx.scale(dpr, dpr);
  var doc = window.document;
  var docEl = doc.documentElement;
  var rem = docEl.getAttribute('data-rem');
  var computedRem = docEl.getAttribute('data-computed-rem'); // 根据flexable的rem和computedRem算出来fontSizeBase，确保图片在修改了系统字体大小的手机上显示正常

  var fontSizeBase = computedRem / rem || 1; // 具名导出使用options参数，更好用，default导出的class参数列表太长了不建议使用

  var canvas2Image = new Canvas2Image({
    canvas: canvas,
    ctx: ctx,
    dpr: dpr,
    fontSizeBase: fontSizeBase,
    exportImage: exportImage
  });
  return canvas2Image.draw(canvasConfig).then(function (res) {
    return res;
  })["catch"](function (err) {
    return Promise.reject(err);
  });
}

export default OldCanvas2Image;
export { Canvas2Image, drawImage, _getDownloadImage as getDownloadImage };
