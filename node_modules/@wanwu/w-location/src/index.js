import {
    fn,
    EventEmitter,
    ua,
} from '@wanwu/base-fn';
import {
    createRtpParams,
} from '@wanwu/base-logger';
import throughParamsPlugin, * as throughParams from '@wanwu/location-plugin-through-params';
import {
    on,
} from '@wanwu/event-utils';
import hdp from '@wanwu/hdp';

const PREVENT_ERROR_TYPE = 'prevent';
const eventCenter = new EventEmitter();

// 给插件提供beforeNavigate事件
eventCenter.$on('beforeNavigate', callBeforeNavigateList);
const tarsksObj = {
    // 插件列表
    pluginList: [
        createRtpParams,
        throughParamsPlugin,
    ],
    // 跳转hook列表
    beforeNavigateList: [],
};

const throttleDoMethod = fn.throttle(doMethod, 300, {
    trailing: false,
});
const wLocation = {
    // vue router实例
    router: null,
    // 需要取的url前缀的正则
    // replaceReg: null,
    // path的前置处理方法
    //  preprocessing = options.preprocessing;
    // 时间戳的key，会加在url上
    timeKey: '__HgWtwYU',
    // pushState的路径存储的key，避免重复pushState
    historyKey: '__mTwWuNi',
    // 错误统一函数处理
    errorCallback: null,
    // 统一域名的正则
    whiteOriginReg: null,
    // 截取base的正则
    catBaseReg: /^\/(\w+-)+web/,

    async push(path, options = {}) {
        // if (isTrottle) {
        //     return throttleDoMethod('push', path);
        // } else {
        //     return doMethod('push', path);
        // }
        return genThrottleDoMethod('push', path, options);
    },

    async replace(path, options = {}) {
        return genThrottleDoMethod('replace', path, options);
        // if (isTrottle) {
        //         return throttleDoMethod('replace', path);
        //     } else {
        //         return doMethod('replace', path);
        //     }
    },

    async go(n) {
        if (this.router) {
            return this.router.go(n);
        } else {
            history.go(n);
        }
    },

    async back() {
        if (this.router) {
            return this.router.back();
        } else {
            history.back();
        }
    },

    async forward() {
        if (this.router) {
            return this.router.forward();
        } else {
            history.forward();
        }
    },

    /**
     *  window.history.pushState的封装，方便返回确认
     * @param {Object} state
     * @param {null} title
     * @param {String} url
     */
    pushState(url, state) {
        const pushHistory = sessionStorage.getItem(this.historyKey);
        const onBrowserBack = () => {
            sessionStorage.removeItem(this.historyKey);
            window.removeEventListener('popstate', onBrowserBack, false);
        };
        window.addEventListener('popstate', onBrowserBack, false);
        if (url !== pushHistory) {
            window.history.pushState(state || window.history.state, '', url);
            sessionStorage.setItem(this.historyKey, url);
        }
    },

    /**
     *  window.history.replaceState的封装，不影响vue router
     * @param {String} url
     */
    replaceState(url) {
        window.history.replaceState(window.history.state, '', url);
    },

    use(plugin) {
        tarsksObj.pluginList.push(plugin);
    },
    /**
     * 添加生命周期函数
     * @param {(to,form)=>void} lifecycle
     */
    beforeNavigate(lifecycle) {
        tarsksObj.beforeNavigateList.push(lifecycle);
    },

    setConfig(options) {
        const pickKeys = [
            'router',
            'replaceReg',
            'timeKey',
            'historyKey',
            'errorCallback',
            'whiteOriginReg',
            'catBaseReg',
        ];
        const newOption = fn.pick(options, pickKeys);
        Object.assign(this, newOption);
    },

    install(Vue, options) {
        this.setConfig(options);
        // const location = new Location(options);
        Vue.prototype.$location = this;
        Vue.location = this;
    },
};

on(document.body, 'click', handleAClick);

function handleAClick(event) {
    let elem = event.target;
    while (elem) {
        if (elem.tagName && elem.tagName.toLowerCase() === 'a' && !elem.hasAttribute('ignoreHijack')) {
            const href = elem.href;
            wLocation.push(href);
            event.preventDefault();
            break;
        } else {
            elem = elem.parentElement;
        }
    }
}

function callBeforeNavigateList(to, from) {
    tarsksObj.beforeNavigateList.forEach(beforeNavigateFn => beforeNavigateFn(fn.clone(to), fn.clone(from)));
}
function prevent(options, THROW) {
    const err = new Error('阻止跳转');
    if (fn.getTypeof(options) === 'string') {
        err.message = options || err.message;
    }
    if (fn.getTypeof(options) === 'object') {
        Object.assign(err, options);
    }
    err.type = PREVENT_ERROR_TYPE;
    if (THROW) {
        return Promise.reject(err);
    } else {
        return Promise.resolve(false);
    }
}

function pathMaker(path, keepState) {
    let query;
    let newPathObj;
    const urlReg = new RegExp('^http(s)?://([\\w-]+.)+[\\w-]+');

    if (path && typeof path === 'string') {
        const pathObj = fn.parseUrl(path);
        newPathObj = {
            path: pathObj.path,
            query: pathObj.params || {},
            hash: pathObj.hash,
        };
    } else if (fn.getTypeof(path) === 'object') {
        const pathObj = fn.parseUrl(path.path || '');
        query = pathObj.params;
        query = Object.assign({}, path.query, query);
        path.query = query;
        path.path = pathObj.path;
        path.hash = pathObj.hash || path.hash;
        newPathObj = path;
    } else {
        return path;
    }
    if (urlReg.test(newPathObj.path)) {
        const URLObj = new URL(newPathObj.path);
        newPathObj.origin = URLObj.origin && URLObj.origin.replace(wLocation.whiteOriginReg, window.location.origin);
        const newPathMatch = URLObj.pathname && URLObj.pathname.match(wLocation.catBaseReg);
        newPathObj.base = (newPathMatch && newPathMatch[0]) || '';
        newPathObj.path = URLObj.pathname && URLObj.pathname.replace(wLocation.catBaseReg, '');
    }
    if (!keepState) {
        const now = Date.now();
        newPathObj.query[wLocation.timeKey] = now;
    }
    if (/^\/.+/.test(newPathObj.path) && fn.typeYalidator.isEmpty(newPathObj.origin) && fn.typeYalidator.isEmpty(newPathObj.base)) {
        if (wLocation.router) {
            newPathObj.base = wLocation.router.history.base;
        }
    }
    if (/^\/.+/.test(newPathObj.path) && fn.typeYalidator.isEmpty(newPathObj.origin)) {
        newPathObj.origin = window.location.origin;
    }
    return newPathObj;
}

async function doMethod(method, path, options = {}) {
    const to = pathMaker(path);
    const from = pathMaker(window.location.href, true);
    let pluginsPromise = Promise.resolve(to);
    tarsksObj.pluginList.forEach(plugin => {
        pluginsPromise = pluginsPromise.then((to) => {
            if (!to) return false;
            return plugin(pathMaker(to), fn.clone(from), prevent, eventCenter, options, method);
        });
    });
    const newTo = await pluginsPromise.catch(err => {
        if (err.type === PREVENT_ERROR_TYPE && wLocation.errorCallback) {
            return wLocation.errorCallback(err);
        }
        return Promise.reject(err);
    });
    if (!newTo) {
        return false;
    }
    callBeforeNavigateList(newTo, from);
    return jump(newTo, from, method, options);
}

async function jump(to, from, method, options = {}) {
    const IsReplace = method === 'replace';
    const newPath = fn.stringifyUrl(`${to.origin || ''}${(to.base && to.base !== '/') ? to.base : ''}${to.path || ''}`, to.query) + (to.hash ? `#${to.hash}` : '');
    const {
        openWebview,
    } = options;
    const hasOpenWebviewOptions = !fn.typeYalidator.isUndefined(openWebview);
    const urlOpenWebview = fn.getQueryString('__openWebview') === 'true';
    const openWebviewFlag = hasOpenWebviewOptions ? openWebview : urlOpenWebview;
    if (openWebviewFlag) {
        if (ua.isApp()) {
            try {
                await hdp.exec('PluginRouter', 'jumpApp', {
                    linkUrl: newPath,
                });
                return;
            } catch (error) {
                // return jumpH5(to, prevent, error);
            }
        } else if (ua.isPC()) {
            window.open(newPath);
            return;
        }
    }
    if (wLocation.router && (new RegExp(`^${window.location.origin || ''}${wLocation.router.history.base || ''}`).test(newPath) || (to.name && !to.path))) {
        return wLocation.router[method](fn.pick(to, [
            'path',
            'name',
            'query',
            'params',
            'hash',
        ]));
    } else {
        if (IsReplace) {
            location.replace(newPath);
        } else {
            location.href = newPath;
        }
    }
}
function genThrottleDoMethod(method, path, options = {}) {
    if (typeof options === 'boolean') {
        options = {
            isTrottle: options,
        };
    }

    const {
        isTrottle = true,
    } = options || {};
    if (isTrottle) {
        return throttleDoMethod(method, path, options || {});
    } else {
        return doMethod(method, path, options || {});
    }
}

export {
    throughParams,
};

export default wLocation;
