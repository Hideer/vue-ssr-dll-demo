/**
 * Create by changsheng on 2019-04-02 14:56
 */

import { fn, ua } from '@wanwu/base-fn';
import { isToControlVersion } from './utils';

const notInAppRejectMessage = '**hdp:环境不是容器';
const { isApp, isIOSApp, isAndroidApp } = ua;

let globalCallbackId = 0;

window.wwdzBridge = window.wwdzBridge || {};

window.wwdzBridge.callback = function (callbackId, status, response) {
    const callback = window.wwdzBridge.callbackMap[callbackId];

    if (callback) {
        let isFinished = true;
        if (status === 'success') {
            callback.success.call(this, response);
        }
        if (status === 'fail') {
            callback.fail.call(this, response);
        }
        if (status === 'progress') {
            callback.progress.call(this, response);
            isFinished = false;
        }

        if (isFinished) {
            window.wwdzBridge.callbackMap[callbackId] = null;
            delete window.wwdzBridge.callbackMap[callbackId];
        }
    }
};

window.wwdzBridge.successCallback = function (callbackId, response) {
    window.wwdzBridge.callback(callbackId, 'success', response);
};

window.wwdzBridge.failCallback = function (callbackId, response) {
    window.wwdzBridge.callback(callbackId, 'fail', response);
};

window.wwdzBridge.callbackMap = {};

function androidExec(success, fail, service, action, args = []) {
    if (!(args && args.length)) {
        args = [{}];
    }
    const callbackId = globalCallbackId++;
    const successCallbackId = `successCallback_${service}_${action}_${callbackId}`;
    const failCallbackId = `failCallback_${service}_${action}_${callbackId}`;

    const successCallback = (response) => {
        if (success && typeof success === 'function') {
            success.call(this, response);
        }

        delete window.wwdzBridge[successCallbackId];
        delete window.wwdzBridge[failCallbackId];
    };

    const failCallback = (error) => {
        if (fail && typeof fail === 'function') {
            fail.call(this, error);
        }

        delete window.wwdzBridge[successCallbackId];
        delete window.wwdzBridge[failCallbackId];
    };

    Object.assign(window.wwdzBridge, {
        [successCallbackId]: successCallback,
        [failCallbackId]: failCallback,
    });

    const functionName = `${service}_${action}`;
    const argsAndroid = args.map((item) => {
        try {
            return JSON.stringify(item);
        } catch (e) {
            return '';
        }
    });

    if (window.wwdzBridge && window.wwdzBridge.hasOwnProperty(functionName) && typeof window.wwdzBridge[functionName] === 'function') {
        try {
            window.wwdzBridge[functionName](`wwdzBridge.${successCallbackId}`, `wwdzBridge.${failCallbackId}`, ...argsAndroid);
        } catch (err) {
            console.log('-------err ' + service + '---' + action, err);
        }
    }
}

function iOSExec(success, fail, service, actions, args) {
    const cordova = window.cordova;
    const cordovaExec = cordova.require('cordova/exec');

    cordovaExec(success, fail, service, actions, args);
}

function iOSExecNew(success, fail, service, actions, args) {
    if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.WKNativeMethodMessage) {
        const callbackId = globalCallbackId++;
        window.wwdzBridge.callbackMap[callbackId] = {
            success,
            fail,
            progress: null,
        };

        window.webkit.messageHandlers.WKNativeMethodMessage.postMessage({
            targetName: service,
            actionName: actions,
            data: args[0],
            identifier: callbackId,
        });
    }
}

function exec(service, action, ...args) {
    return new Promise((resolve, reject) => {
        // [FIX]是否进行版本控制的比较
        if (isIOSApp() && (isToControlVersion() && fn.compareVersion(ua.getAppVersion(), '2.2.0') < 0)) {
            deviceReady().then(() => {
                iOSExec((res) => {
                    resolve(res);
                }, (err) => {
                    reject(err);
                }, service, action, args);
            }).catch((error) => {
                reject(error);
            });
        } else if (isIOSApp()) {
            iOSExecNew((res) => {
                resolve(res);
            }, (err) => {
                console.log('iOSExecNew err', err);

                reject(err);
            }, service, action, args);
        } else if (isAndroidApp()) {
            androidExec((res) => {
                resolve(res);
            }, (err) => {
                console.log('androidExec err', err);

                reject(err);
            }, service, action, args);
        } else {
            reject(new Error(notInAppRejectMessage));
        }
    });
}

let _isReady = false;

function deviceReady() {
    return new Promise((resolve, reject) => {
        if (_isReady) {
            resolve();
        } else {
            if (isApp()) {
                document.addEventListener('deviceready', () => {
                    _isReady = true;
                    resolve();
                }, false);
            } else {
                reject(new Error(notInAppRejectMessage));
            }
        }
    });
}

// [FIX]是否进行版本控制的比较
if (isToControlVersion() && fn.compareVersion(ua.getAppVersion(), '2.1.5') < 0) {
    deviceReady().catch((error) => {
        console.warn(error.message);
    });
}

const execRequest = (service, action, ...args) => {
    const config = {};

    return exec(service, action, ...args).then(res => {
        let data;
        if (res) {
            data = res.data;
            // data.payload = res;
        }
        if (config.skipFilter) {
            return res;
        } else if (res && res.code === 1001) {
            return data;
        } else {
            const error = new Error((res && res.message) || `${service}_${action}:未定义错误`);
            error.payload = res;
            return Promise.reject(error);
        }
    }).catch(err => {
        return Promise.reject(err);
    });
};

const hdp = {
    exec,
    execRequest,
};
export default hdp;

window.hdp = hdp;
