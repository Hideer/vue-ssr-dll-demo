<template>
    <div class="component__swipe swipe">
        <!-- 滑动track容器 -->
        <div
            ref="track"
            :style="trackStyle"
            :vertical="true"
            class="swipe__track"
            @touchstart="onTouchStart"
            @touchmove="onTouchMove"
            @touchend="onTouchEnd"
            @touchcancel="onTouchEnd"
        >
            <!-- 轮播插槽 -->
            <slot></slot>
        </div>
        <!-- 轮播指示器插槽 -->
        <slot name="indicator">
            <div
                v-if="showIndicators"
                :class="{
                    swipe__indicators: true,
                    'swipe__indicators--vertical': vertical
                }"
            >
                <i
                    v-for="(item, index) in Array(count)"
                    :key="index"
                    :class="{
                        'swipe__indicator--active': index === activeIndicator,
                        swipe__indicator: true
                    }"
                    :style="index === activeIndicator ? indicatorStyle : null"
                ></i>
            </div>
        </slot>
    </div>
</template>

<script>
    import mixinTouch from '@wanwu/base-vue-mixin-touch';
    export default {
        name: 'Swipe',
        components: {},
        mixins: [
            mixinTouch,
        ],
        props: {
            width: {
                type: Number,
                default: 0,
            },
            height: {
                type: Number,
                default: 0,
            },
            autoplay: {
                type: Number,
                default: 0,
            },
            vertical: Boolean,
            initialSwipe: {
                type: Number,
                default: 0,
            },
            indicatorColor: String,
            loop: {
                type: Boolean,
                default: true,
            },
            touchable: {
                type: Boolean,
                default: true,
            },
            showIndicators: {
                type: Boolean,
                default: true,
            },
            duration: {
                type: Number,
                default: 500,
            },
            // trank整体的偏移量
            offsetNum: {
                type: Number,
                default: 0,
            },
            distance: {
                type: Number,
                default: 0,
            },
        },
        data() {
            return {
                computedWidth: 0,
                computedHeight: 0,
                offset: 0,
                active: 0,
                deltaX: 0,
                deltaY: 0,
                swipes: [],
                swiping: false,
            };
        },

        computed: {
            count() {
                return this.swipes.length;
            },

            delta() {
                return this.vertical ? this.deltaY : this.deltaX;
            },

            size() {
                return this[this.vertical ? 'computedHeight' : 'computedWidth'];
            },

            trackSize() {
                return this.count * this.size;
            },

            activeIndicator() {
                return (this.active + this.count) % this.count;
            },

            isCorrectDirection() {
                const expect = this.vertical ? 'vertical' : 'horizontal';
                return this.direction === expect;
            },

            trackStyle() {
                const mainAxis = this.vertical ? 'height' : 'width';
                const crossAxis = this.vertical ? 'width' : 'height';
                return {
                    [mainAxis]: `${this.trackSize}px`,
                    [crossAxis]: this[crossAxis] ? `${this[crossAxis]}px` : '',
                    transitionDuration: `${this.swiping ? 0 : this.duration}ms`,
                    transform: `translate${this.vertical ? 'Y' : 'X'}(${this.offset +
                        this.offsetNum}px)`,
                };
            },

            indicatorStyle() {
                return {
                    backgroundColor: this.indicatorColor,
                };
            },
        },
        watch: {
            swipes() {
                this.initialize();
            },
            initialSwipe() {
                this.initialize();
            },

            autoplay(autoplay) {
                if (!autoplay) {
                    this.clear();
                } else {
                    this.autoPlay();
                }
            },
        },
        mounted() {
            this.initialize();
            if (!this.$isServer) {
                window.addEventListener('resize', this.onResize, {
                    capture: false,
                    passive: true,
                });
            }
        },
        activated() {
            // if (this.rendered) {
            //     this.initialize(this.active);
            // }

            // this.rendered = true;
            this.autoPlay();
        },
        deactivated() {
            this.clear();
        },

        destroyed() {
            this.clear();
            if (!this.$isServer) {
                window.removeEventListener('resize', this.onResize);
            }
        },
        methods: {
            // initialize swipe position
            initialize(active = this.initialSwipe) {
                clearTimeout(this.timer);
                if (this.$el) {
                    const rect = this.$el.getBoundingClientRect();
                    this.computedWidth = this.width || rect.width;
                    this.computedHeight = this.height || rect.height;
                }
                this.swiping = true;
                this.active = active;
                this.offset = this.count > 1 ? -this.size * this.active : 0;

                this.swipes.forEach(swipe => {
                    swipe.offset = 0;
                });
                this.autoPlay();
                if (this.offsetNum && this.count > 2 && this.loop && this.swipes[this.count - 1]) {
                    this.swipes[this.count - 1].offset = -this.trackSize;
                }
            // this.move({
            //     pace: 1,
            //     offset: 0,
            // });
            },

            onResize() {
                setTimeout(() => {
                    this.initialize(this.activeIndicator);
                });
            },
            onTouchStart(event) {
                if (!this.touchable) return;
                if (event.target.closest('.swiper-no-swiping')) return;
                this.clear();
                this.swiping = true;
                this.touchStart(event);
                this.correctPosition();
            },

            onTouchMove(event) {
                if (!this.touchable || !this.swiping) return;

                this.touchMove(event);

                if (this.isCorrectDirection) {
                    event.cancelable && event.preventDefault();
                    event.stopPropagation();
                    this.move({
                        offset: Math.min(Math.max(this.delta, -this.size), this.size),
                    });
                }
            },

            onTouchEnd() {
                if (!this.touchable || !this.swiping) return;
                if (this.isCorrectDirection) {
                    let pace = 0;
                    const offset = this.vertical ? this.offsetY : this.offsetX;
                    if (Math.abs(this.delta) > this.distance) {
                        pace = offset > 0 ? (this.delta > 0 ? -1 : 1) : 0;
                    }
                    this.move({
                        pace: pace,
                        emitChange: true,
                    });
                }

                this.swiping = false;
                this.autoPlay();
            },

            move({
                pace = 0, offset = 0, emitChange,
            }) {
                const {
                    delta, active, count, swipes, trackSize, offsetNum,
                } = this;
                const atFirst = offsetNum && count > 2 && this.loop ? active <= 1 : active === 0;
                const atSecond = active <= 0;
                const atLast =
                    offsetNum && count > 2 && this.loop ? active >= count - 2 : active === count - 1;
                const atLastSecond = active >= count - 1;
                const outOfBounds =
                    !this.loop &&
                    ((atFirst && (offset > 0 || pace < 0)) ||
                        (atLast && (offset < 0 || pace > 0)));

                if (outOfBounds || count <= 1) {
                    return;
                }

                if (swipes[0]) {
                    swipes[0].offset = atLast && (delta < 0 || pace > 0) ? trackSize : 0;
                }
                if (offsetNum && count > 2 && swipes[1] && this.loop) {
                    swipes[1].offset =
                        atLastSecond && (delta < 0 || pace > 0) ? trackSize : 0;
                }
                if (swipes[count - 1]) {
                    swipes[count - 1].offset =
                        atFirst && (delta > 0 || pace < 0) ? -trackSize : 0;
                }
                if (offsetNum && count > 2 && swipes[count - 2] && this.loop) {
                    swipes[count - 2].offset =
                        atSecond && (delta > 0 || pace < 0) ? -trackSize : 0;
                }
                if (pace && active + pace >= -1 && active + pace <= count) {
                    this.active += pace;

                    if (emitChange) {
                        this.$emit('change', this.activeIndicator);
                    }
                }
                const num = Math.round(offset - this.active * this.size);
                this.$emit('offset', num, this.active, this.face);
                this.offset = num;
            },

            swipeTo(index, emitChange = true) {
                this.swiping = true;
                this.resetTouchStatus();
                this.correctPosition();
                setTimeout(() => {
                    this.swiping = false;
                    this.move({
                        pace: (index % this.count) - this.active,
                        emitChange,
                    });
                }, 30);
            },

            correctPosition() {
                if (this.active <= -1) {
                    this.move({
                        pace: this.count,
                    });
                }
                if (this.active >= this.count) {
                    this.move({
                        pace: -this.count,
                    });
                }
            },

            clear() {
                clearTimeout(this.timer);
            },

            autoPlay() {
                const {
                    autoplay,
                } = this;

                if (autoplay && this.count > 1) {
                    this.clear();
                    this.timer = setTimeout(() => {
                        this.swiping = true;
                        this.resetTouchStatus();
                        this.correctPosition();

                        setTimeout(() => {
                            this.swiping = false;
                            this.move({
                                pace: 1,
                                emitChange: true,
                            });
                            this.autoPlay();
                        }, 30);
                    }, autoplay);
                }
            },
        },
    };
</script>

<style lang='less' scoped>
    @swipe-indicator: 10px;
    @border-color: #ebedf0;

    .component__swipe {
        overflow: hidden;
        position: relative;
        user-select: none;

        .swipe {
            &__track {
                height: 100%;
            }

            &__indicator {
                opacity: 0.3;
                border-radius: 50%;
                width: @swipe-indicator;
                height: @swipe-indicator;
                transition: opacity 0.2s;
                background-color: rgba(216, 216, 216, 1);

                &:not(:last-child) {
                    margin-right: @swipe-indicator;
                }

                &--active {
                    opacity: 1;
                    background-color: rgba(234, 49, 62, 1);
                }
            }

            &__indicators {
                display: flex;
                position: absolute;
                left: 50%;
                bottom: 10px;
                transform: translateX(-50%);

                &--vertical {
                    left: 10px;
                    top: 50%;
                    bottom: auto;
                    flex-direction: column;
                    transform: translateY(-50%);

                    .swipe__indicator:not(:last-child) {
                        margin-bottom: @swipe-indicator;
                    }
                }
            }
        }
    }
</style>
