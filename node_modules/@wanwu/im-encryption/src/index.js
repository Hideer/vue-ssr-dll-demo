import sign from './sign/sign-encryption';
var base64 = require('./base64/base64');
var typeUtils = require('./utils/type-utils');
var signUtils = require('./utils/sign-utils');

var KEYV = [
    0x3456189a,
    0x1123ef23,
    0x7abc7910,
    0x11879034,
];// 加密解密所用的KEY

var salt = 0x120cd38d;
var tea_round = 32;

var key = new Array(4);

function TeaEncryption(sId, keyStr) {
    if (keyStr.length !== 32) {
        throw new Error('KeyStr Error!');
    }
    this.sId = sId;
    const keyInt = [
        hash(keyStr.substring(0, 8)),
        hash(keyStr.substring(8, 16)),
        hash(keyStr.substring(16, 24)),
        hash(keyStr.substring(24, 32)),
    ];
    for (var i = 4; i > 0; i--) {
        key[4 - i] = keyInt[i - 1] ^ salt;
    }

    if (this.sId !== '' && this.sId !== null) {
        var sIdHash = hash(this.sId);
        for (let i = 0; i < 4; i++) {
            key[i] = key[i] ^ sIdHash;
        }
    }
}

function OldTeaEncryption(sId) {
    this.sId = sId;
    for (var i = 4; i > 0; i--) {
        key[4 - i] = KEYV[i - 1] ^ salt;
    }

    if (this.sId !== '' && this.sId !== null) {
        var sIdHash = hash(this.sId);
        for (let i = 0; i < 4; i++) {
            key[i] = key[i] ^ sIdHash;
        }
    }
}

function hash(str) {
    var strByte = typeUtils.toUTF8Array(str);
    var hash = 5381;
    for (var i = 0; i < strByte.length; i++) {
        hash = ((hash << 5) + hash) + strByte[i]; /* hash * 33 + c */
    }
    return hash & 0xffffffffff;
}

/**
 * 加密8个字节数据，也就是两个int类型数据
 * @param content
 * @param offset 字节数据下标
 * @param key
 * @param times 加密轮数
 * @return
 */
function encrypt(content, offset, key, times) {
    var tempInt = typeUtils.byteToInt(content, offset);
    var y = tempInt[0] >>> 0; var z = tempInt[1] >>> 0; var sum = 0; var i;
    var delta = 0x9e3779b9; // 这是算法标准给的值
    var a = key[0]; var b = key[1]; var c = key[2]; var d = key[3];

    for (i = 0; i < times; i++) {
        sum += delta;
        y += ((z << 4) + a) ^ (z + sum) ^ ((z >>> 5) + b);
        z += ((y << 4) + c) ^ (y + sum) ^ ((y >>> 5) + d);
        // 每次把y,z转成无符号类型
        y = y >>> 0;
        z = z >>> 0;
    }

    tempInt[0] = y;
    tempInt[1] = z;
    // System.out.printf("%d %d", y, z);
    return typeUtils.intToByte(tempInt, 0);
}

/**
 * 解密8个字节数据，也就是两个int类型数据
 * @param encryptContent
 * @param offset 字节数据下标
 * @param key
 * @param times 加密轮数
 * @return
 */
function decrypt(encryptContent, offset, key, times) {
    var tempInt = typeUtils.byteToInt(encryptContent, offset);
    var y = tempInt[0]; var z = tempInt[1]; var sum = 0; var i;
    var delta = 0x9e3779b9; // 这是算法标准给的值
    var a = key[0]; var b = key[1]; var c = key[2]; var d = key[3];
    if (times === 32) { sum = 0xC6EF3720; } else if (times === 16) { sum = 0xE3779B90; } else { sum = delta * times; }

    for (i = 0; i < times; i++) {
        z -= ((y << 4) + c) ^ (y + sum) ^ ((y >>> 5) + d);
        y -= ((z << 4) + a) ^ (z + sum) ^ ((z >>> 5) + b);
        sum -= delta;
    }
    tempInt[0] = y;
    tempInt[1] = z;

    return typeUtils.intToByte(tempInt, 0);
}

// 通过TEA算法加密信息 参数类型：stirng
function encryptBase64(info) {
    var temp = typeUtils.toUTF8Array(info);
    var n = 8 - temp.length % 8;// 若temp的位数不足8的倍数,需要填充的位数
    var encryptStr = new Array(temp.length + n);

    for (var i = 0; i < encryptStr.length; i++) {
        if (i >= temp.length) {
            encryptStr[i] = n;
        } else {
            encryptStr[i] = temp[i];
        }
    }
    var result = new Array(encryptStr.length);

    for (var offset = 0; offset < result.length; offset += 8) {
        var tempEncrpt = encrypt(encryptStr, offset, key, tea_round);
        for (let o = offset, i = 0; o < offset + 8; o++, i++) {
            result[o] = tempEncrpt[i];
        }
    }

    return base64.fromByteArray(result);
}

// 通过TEA算法加密信息 参数类型：JSONOBJECT
function encryptJsonBase64(jsonObject) {
    var paramMap = new Map();

    for (var val in jsonObject) {
        if (typeof val === 'string' && typeof jsonObject[val] === 'string') {
            console.log(val + ' ' + jsonObject[val]);
            paramMap.set(val, jsonObject[val]);
        }
    }

    var info = signUtils.getParamStr(paramMap);

    var temp = typeUtils.toUTF8Array(info);
    var n = 8 - temp.length % 8;// 若temp的位数不足8的倍数,需要填充的位数
    var encryptStr = new Array(temp.length + n);

    for (var i = 0; i < encryptStr.length; i++) {
        if (i >= temp.length) {
            encryptStr[i] = n;
        } else {
            encryptStr[i] = temp[i];
        }
    }
    var result = new Array(encryptStr.length);

    for (var offset = 0; offset < result.length; offset += 8) {
        var tempEncrpt = encrypt(encryptStr, offset, key, tea_round);
        for (let o = offset, i = 0; o < offset + 8; o++, i++) {
            result[o] = tempEncrpt[i];
        }
    }

    return base64.fromByteArray(result);
}

// 通过TEA算法解密信息
function decryptBase64(secretInfoBase, sid) {
    var secretInfo = base64.toByteArray(secretInfoBase);
    var decryptStr = null;
    var tempDecrypt = new Array(secretInfo.length);
    new OldTeaEncryption(sid);

    if (secretInfo.length % 8 !== 0) {
        throw new Error('Abnormal encryption format!');
    }

    for (var offset = 0; offset < secretInfo.length; offset += 8) {
        decryptStr = decrypt(secretInfo, offset, key, tea_round);
        for (var o = offset, i = 0; o < offset + 8; o++, i++) {
            tempDecrypt[o] = decryptStr[i];
        }
        // System.arraycopy(decryptStr, 0, tempDecrypt, offset, 8);
    }

    // n为填充的数组元素数量
    var n = tempDecrypt[secretInfo.length - 1];
    console.log('n:' + n);

    if (!(n > 0 && n <= 8) || paddingCheck(tempDecrypt, n)) {
        throw new Error('Abnormal encryption format!');
    }
    var tempDecryptResult = new Array(secretInfo.length - n);
    for (let i = 0; i < tempDecrypt.length - n; i++) {
        tempDecryptResult[i] = tempDecrypt[i];
    }
    // return byteToString(tempDecryptResult);
    // return String.fromCharCode.apply(null,tempDecryptResult);
    return typeUtils.fromUTF8Array(tempDecryptResult);
}

function paddingCheck(tempDecrypt, n) {
    var k = n;
    while (n > 0) {
        if (tempDecrypt[tempDecrypt.length - n] !== k) {
            return true;
        }
        n--;
    }
    return false;
}


export function outerEncrypt(content, key) {
    const {
        appVersion = '', signVersion = '', h5sId = '',
    } = window.ENCRYPT_KEY || {};
    var timestamp = Math.floor(new Date().getTime() / 1000);
    var obj = {
        appVersion: appVersion,
        content: content,
        sign: sign(h5sId, timestamp, appVersion, signVersion, content, new Map()),
        signVersion: signVersion,
        timestamp: timestamp,
    };
    if (key) {
        new TeaEncryption(h5sId, key);
    } else {
        new OldTeaEncryption(h5sId);
    }

    return encryptBase64(JSON.stringify(obj));
}

export function outerDecrypt(eninfo) {
    const arr = [
        '200100',
        '100100',
        '300100',
        '400100',
    ];
    let str = eninfo;
    arr.some((key) => {
        try {
            str = JSON.parse(decryptBase64(eninfo, key)).content;
            return true;
        } catch (e) {
            console.log('解密发现异常', e);
        }
    });
    return str;
}
export function signature(timestamp, payload, headerMap) {
    const {
        appVersion = '', signVersion = '', h5sId = '',
    } = window.ENCRYPT_KEY || {};
    return sign(h5sId, timestamp, appVersion, signVersion, payload, headerMap);
}

export default {
    encrypt: outerEncrypt,
    decrypt: outerDecrypt,
    sign: signature,
};
