import {
    fn, ImageUtils,
} from '@wanwu/base-fn';
import { WANWUConfig } from '@wanwu/base-fn';
const {
    throttle,
} = fn;
const DEFAULT_EVENTS = [
    'scroll',
    'wheel',
    'mousewheel',
    'resize',
    'animationend',
    'transitionend',
    'touchmove',
];

// 声明size
/**
 * 图片及尺寸信息
 * @typedef {Object} ImageSize
 * @property {number} width 宽度
 * @property {number} height 高度
 */
/**
 * 图片及尺寸信息
 * @typedef {Object} ImageInfo
 * @property {string} url 图片链接
 * @property {number} width 宽度
 * @property {number} height 高度
 */

// window事件绑定状态
let isWindowBind = false;
// 需要进行监听的图片列表，还没有加载过的
const listenList = [];
// 已经缓存好的图片列表
const imageCacheList = [];
// 父容器列表
let contentList = [];
// 默认图片
// const defaultImg = 'https://cdn.wanwudezhi.com/static/web-static/image/5dc5f4919f413689b14dcd58b48d81f9.png';
// Vue 图片懒加载，导出模块
const getLazyFn = (options = {}) => {
    // preLoad 配置懒加载图片加载范围，数字类型，默认2，代表图片进入视窗的上下左右两屏范围内就开始加载
    options.preLoad = options.preLoad ? Number(options.preLoad) : 2;
    options.listenEvents = options.listenEvents || DEFAULT_EVENTS;
    // loadingImg预设图片的数组，不同尺寸的图片越多，适配越好
    const loadingImgMap = {
        wwdz: [
            // NOTE：统一风格
            // 'https://cdn.wanwudezhi.com/static/web-static/image/081fcc0378d010cc02e3b0ab52291a30_555x555.png',
            // 'https://cdn.wanwudezhi.com/static/web-static/image/bf902b6388fddec8b17139047ae05978_507x759.png',
            // 'https://cdn.wanwudezhi.com/static/web-static/image/1f4503d4c57799bc1e5c5067d54bb977_1125x411.png',
            'https://cdn.wanwudezhi.com/static/web-static/image/dce7fd206a6a8a429c338be06ba1c560_555x555.png',
            'https://cdn.wanwudezhi.com/static/web-static/image/8a4b71aaebc621003d20d7e2c16c5958_507x759.png',
            'https://cdn.wanwudezhi.com/static/web-static/image/bd05f1d3974dd67a2e8c49b47d7b74bb_1125x411.png',
        ],
        common: [
            'https://cdn.wanwudezhi.com/static/web-static/image/c14bbc7cdc2c6d133aad71487b5a0b66_555x555.png',
            'https://cdn.wanwudezhi.com/static/web-static/image/0299417d8599cbfc33fc8d0eb690e759_507x759.png',
            'https://cdn.wanwudezhi.com/static/web-static/image/a2b0ab7ad66a84c5c61bef7cceb17a10_1125x411.png',
        ],
    };

    let loadingImgs = loadingImgMap.wwdz;
    // 将次优先级至于query中，option之后；即被覆盖的顺序为：wanwuConfig < query < options
    const wanwuConfig = new WANWUConfig();
    const imgKey_wanwuConfig = wanwuConfig.getConfig('base-vue-directive-lazy', 'imgKey');
    if (imgKey_wanwuConfig && loadingImgMap[imgKey_wanwuConfig]) {
        loadingImgs = loadingImgMap[imgKey_wanwuConfig];
    }
    if (fn.getQueryString('hidewwdz') === '1') {
        // 初始化时赋值到全局 给其他组件使用
        window.hidewwdz = true;
        loadingImgs = loadingImgMap.common;
    }
    if (loadingImgMap[options.imgKey]) {
        loadingImgs = loadingImgMap[options.imgKey];
    }

    // errorImgs预设图片的数组，不同尺寸的图片越多，适配越好
    const errorImgs = [
        'https://cdn.wanwudezhi.com/static/web-static/image/fdaa64918a5a15e53fc1a87c9d870e61_555x555.png',
    ];
    // 默认加载图片
    const perchImg = {
        loading: loadingImgs[0],
        error: errorImgs[0],
    };

    // loading图片的对象数组，包含URL和尺寸
    const loadingImgsObjList = loadingImgs.map((item) => {
        const {
            width, height,
        } = getDefaultSize(item);
        return {
            url: item,
            width,
            height,
        };
    });
    // error图片的对象数组，包含URL和尺寸
    const errorImgsObjList = errorImgs.map((item) => {
        const {
            width, height,
        } = getDefaultSize(item);
        return {
            url: item,
            width,
            height,
        };
    });

    /**
     * 数组item remove方法
     * @param {*} item [数组要删除的item]
     */
    const ArrayRemove = function (arr, item) {
        if (!arr.length) return [];
        var index = arr.indexOf(item);
        if (index > -1) {
            arr.splice(index, 1);
            return arr;
        }
        return arr;
    };

    /**
     * 判断是否已经加载过了
     * @param {*} imageSrc [图片src]
     */
    const isAlredyLoad = imageSrc => {
        if (imageCacheList.indexOf(imageSrc) > -1) {
            return true;
        } else {
            return false;
        }
    };
    /**
     * 检测图片是否可以加载，如果可以则进行加载
     * @param {*} item [图片对象]
     */
    const isCanShow = item => {
        const ele = item.ele;
        const src = item.src;
        // 图片的rect对象
        const rect = ele.getBoundingClientRect();
        // 页面可视区域的高度
        const windowHeight = window.innerHeight;
        // 页面可视区域的宽度
        const windowWidth = window.innerWidth;
        // 判断元素是否已经进入了可视区域
        const checkInView =
            typeof window !== 'undefined' &&
            (rect.top <= windowHeight * options.preLoad && rect.bottom >= 0) &&
            (rect.left <= windowWidth * options.preLoad && rect.right >= 0);
        if (checkInView) {
            var image = new Image();
            image.src = src;
            image.onload = function () {
                ele.src = src;
                imageCacheList.push(src);
                ArrayRemove(listenList, item);
                // console.log(item.vnode.context.initImg);
                if (item.vnode.context.initImg) {
                    // console.log(123);
                    item.vnode.context.initImg(image);
                }
            };
            image.onerror = function () {
                ele.src = item.error || src;
                ArrayRemove(listenList, item);
            };
            return true;
        } else {
            return false;
        }
    };
    // 添加监听事件scroll
    const onScroll = throttle(
        function () {
            listenList.forEach(item => {
                isCanShow(item);
            });
        },
        150,
    );
    /**
     * 绑定监听事件
     * @param {dom} containerEl 父容器
     */
    const onListenScroll = containerEl => {
        if (!isWindowBind) {
            options.listenEvents.forEach(evt => {
                window.addEventListener(evt, onScroll);
            });
            isWindowBind = true;
        }
        if (containerEl && contentList.indexOf(containerEl) === -1) {
            options.listenEvents.forEach(evt => {
                containerEl.addEventListener(evt, onScroll);
            });

            contentList.push(containerEl);
        }
    };
    // addListener为Vue指令的具体实现功能函数，我们这里为所有使用v-lazyload的指令的元素添加监听
    // ele是dom元素，binding是绑定的具体值
    /**
     * Vue指令的具体实现功能函数
     * @param {*} ele [对应元素]
     * @param {*} binding [包含指令对应value的对象]
     */
    const addListener = (ele, binding, vnode) => {
        // 绑定的图片地址
        let imageSrc;
        let arg;
        // const isElSrcOk = ele.src && !new RegExp(`(${options.loading}|${options.error})`).test(ele.src);
        const value = binding.value;
        if (typeof value === 'string') {
            imageSrc = binding.value;
        } else if (value instanceof Object) {
            arg = value;
            imageSrc = value.url;
        }
        // 已经加载的图片不重复加载
        if (ele.src === imageSrc) {
            return false;
        }

        // 容器选择器
        const container = Object.keys(binding.modifiers)[0];
        let containerEl = vnode.context.$refs[container];
        if (container) {
            containerEl = containerEl
                ? containerEl.$el || containerEl
                : document.getElementById(container);
        }
        // 如果已经加载过，则无需重新加载，直接将src赋值
        if (isAlredyLoad(imageSrc)) {
            ele.src = imageSrc;
            ele.onload = () => {
                vnode.context.$nextTick(() => {
                    if (vnode.context.initImg) {
                        vnode.context.initImg(ele);
                    }
                });
            };

            return false;
        }
        var item = {
            ele,
            src: imageSrc,
            vnode,
            ...perchImg,
        };
        // 把图片src设置到元素的属性上，方便排查错误
        ele.setAttribute('data-src', imageSrc);
        // 监听页面scroll事件
        onListenScroll(containerEl);
        // targetImgSize：从指令的arg或value或者从图片地址上解析的尺寸对象{width,height}
        const targetImgSize = binding.arg || arg || getDefaultSize(imageSrc);
        if (targetImgSize && targetImgSize.width && targetImgSize.height) {
            // 使用七牛cdn获取尺寸最接近的预设图片
            const loadingImgObj = getCloseToImgSizeObj(targetImgSize, loadingImgsObjList);
            const {
                width: loadingWdith,
                height: loadingHeight,
            } = getPrechImgSize(targetImgSize, loadingImgObj);
            item.loading = ImageUtils.getRectangleImage(loadingImgObj.url, {
                cut: true,
                width: loadingWdith,
                height: loadingHeight,
            });
            const errorImgObj = getCloseToImgSizeObj(targetImgSize, errorImgsObjList);
            const {
                width: errorWdith,
                height: errorHeight,
            } = getPrechImgSize(targetImgSize, errorImgObj);
            item.error = ImageUtils.getRectangleImage(perchImg.error, {
                cut: true,
                width: errorWdith,
                height: errorHeight,
            });
        }
        if (!imageSrc) {
            ele.src = item.error;
            return console.error('图片链接缺失');
        } else {
            ele.src = item.loading;
        }
        // 再看是否可以显示此图片
        if (isCanShow(item)) {
            return;
        }
        // 否则将图片地址和元素均放入监听的listenList
        listenList.push(item);

        setTimeout(() => {
            isCanShow(item);
        }, 100);
    };
    return {
        // bind: addListener,
        inserted: addListener,
        // updated: addListener,
        componentUpdated: addListener,
        unbind: () => {
            // listenList = [];
            contentList = [];
        },
    };
};
export {
    getLazyFn,
};
export default {
    install(Vue, options) {
        const lazy = getLazyFn(options);
        // Vue自定义指令，lazy为指令的名称
        Vue.directive('lazy', lazy);
    },
};

/**
 *获取数组中最接近传入数字的值的index
 * @param {number} num 数字
 * @param {Array<number>} numList 数字数组
 * @returns {number} 数组下标
 */
function closeToNumIndex(num, numList) {
    // 返回值：数组最接近项的下标，默认值0
    let numIndex = 0;
    // 数字与数组每项的差当前最小值
    let minAbstand = -1;
    // 遍历数组
    for (const index in numList) {
        const item = numList[index];
        // 得到当前项和目标数字的差
        const abstand = (item < num) ? num - item : item - num;

        if (minAbstand === -1) { // 如果是第一次遍历，最小差为默认的-1，则当前最小差为当前的差
            minAbstand = abstand;
            continue;
        } else if (abstand < minAbstand) { // 如果当前的差小于当前缓存的最小差，则把最小差换成当前的差，并且数组最接近项的下标赋值为当前下标
            minAbstand = abstand;
            numIndex = index;
        }//  如果当前的差大于当前缓存的最小差，则不处理
    }
    return numIndex;
}
/**
 * 从七牛图片链接中获取图片尺寸
 * @param {string} src 七牛图片链接
 * @returns {object} 图片宽高对象
 */
function getDefaultSize(src) {
    const origin = ImageUtils.getOriginImage(src);
    const reg = /^https?:\/\/cdn\.wanwudezhi\.com\/.*_(\d+x\d+)\.\w+/;
    if (reg.test(origin)) {
        const nums = (origin.match(reg)[1] || '').split('x');
        const width = nums[0];
        const height = nums[1];
        return {
            width,
            height,
        };
    }
}

/**
 * 获取预设图片裁切尺寸对象
 * @param {{width:number,height:number}} arg 图片尺寸对象
 * @param {{width:number,height:number}} prechImgArg 预设图片尺寸对象
 * @returns {{width:number,height:number}} 预设图片裁切尺寸对象
 */
function getPrechImgSize(arg, prechImgArg) {
    let width;
    let height;
    if (getScale(arg) > getScale(prechImgArg)) {
        width = prechImgArg.width;
        height = Math.round(width / arg.width * arg.height);
    } else {
        height = prechImgArg.height;
        width = Math.round(height / arg.height * arg.width);
    }
    if (!(width && height)) {
        width = prechImgArg.width;
        height = prechImgArg.height;
    }
    return {
        width,
        height,
    };
}
/**
 *获取尺寸接近的预设图对象
 * @param {{width:number,height:number}} targetImgObj 目标图片尺寸
 * @param {Array<{width:number,height:number,url:string}>} imgsObjList 预设图对象数组
 * @returns {{width:number,height:number,url:string}} 预设图对象
 */
function getCloseToImgSizeObj(targetImgObj, imgsObjList) {
    const scales = imgsObjList.map(getScale);
    const targetScale = getScale(targetImgObj);
    const index = closeToNumIndex(targetScale, scales);
    return imgsObjList[index];
}
/**
 *  获取宽高比例
 * @param {{width:number,height:number}} size
 * @returns {number}
 */
function getScale(size) {
    return size.width / size.height;
}
