'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

require('core-js/modules/es.array.index-of');
require('core-js/modules/es.date.to-string');
require('core-js/modules/es.function.bind');
require('core-js/modules/es.object.assign');
require('core-js/modules/es.object.to-string');
require('core-js/modules/es.regexp.exec');
require('core-js/modules/es.regexp.to-string');
require('core-js/modules/es.string.split');
var _classCallCheck = _interopDefault(require('@babel/runtime/helpers/esm/classCallCheck'));
var _createClass = _interopDefault(require('@babel/runtime/helpers/esm/createClass'));
var _defineProperty = _interopDefault(require('@babel/runtime/helpers/esm/defineProperty'));
var baseFn = require('@wanwu/base-fn');
var baseLogger = require('@wanwu/base-logger');
require('core-js/modules/es.array.for-each');
require('core-js/modules/web.dom-collections.for-each');

var isDebug = baseFn.fn.getQueryString('__debug'); // 获取在可视区范围内的位置
// const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
// const viewPortWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
// const getInViewPos = (pos, direction) => {
//     const viewPortValue = direction === 'v' ? viewPortHeight : viewPortWidth;
//     if (pos < 0) return 0;
//     if (pos > viewPortValue) return viewPortValue;
//     return pos;
// };
// 获取路由相对地址

function GetUrlRelativePath() {
  var url = document.location.toString();
  var arrUrl = url.split('//');
  var start = arrUrl[1].indexOf('/');
  var relUrl = arrUrl[1].substring(start); // stop省略，截取从start开始到结尾的所有字符

  if (relUrl.indexOf('?') !== -1) {
    relUrl = relUrl.split('?')[0];
  }

  return relUrl;
}

var LogScroll = /*#__PURE__*/function () {
  function LogScroll(props) {
    _classCallCheck(this, LogScroll);

    _defineProperty(this, "isPost", false);

    _defineProperty(this, "listenIdx", 0);

    _defineProperty(this, "listenObj", {});

    _defineProperty(this, "listenVm", {});

    _defineProperty(this, "viewRatio", 0.5);

    this.el = props.el;
    this.logData = props.binding.value;
    this.logConfig = Object.assign({
      isAlive: true,
      isRigorous: true
    }, props.binding.arg || {}); // isAlive：是否敏感的，重复上报； isRigorous：是否严谨的，是否首次上报需暴露在视窗内

    this.vnode = props.vnode;
    this.currUrl = this.getCurrUrl();
    this.onScrollEvent = baseFn.fn.throttle(this.onScroll.bind(this), 200);
    this.onListenScroll();

    if (this.logConfig.isRigorous) {
      this.onScrollEvent();
    } else {
      this.onLogger(this.logData);
    }
  } // 缓存打点数据


  _createClass(LogScroll, [{
    key: "getCurrUrl",
    // 获取当前路由地址（确保监听的准确性）
    value: function getCurrUrl() {
      return GetUrlRelativePath();
    } // 滚动监听

  }, {
    key: "onListenScroll",
    value: function onListenScroll() {
      window.addEventListener('scroll', this.onScrollEvent);
      window.addEventListener('touchmove', this.onScrollEvent);
    } // 滚动卸载

  }, {
    key: "unListenScroll",
    value: function unListenScroll() {
      console.log('移除事件监听');
      window.removeEventListener('scroll', this.onScrollEvent);
      window.removeEventListener('touchmove', this.onScrollEvent);
    } // 检测是否在可视区范围（超过一半）

  }, {
    key: "isInView",
    value: function isInView(el) {
      // const rect = el.getBoundingClientRect();
      // const { top, bottom, left, right, width, height } = rect || {};
      // const _top = getInViewPos(top, 'v');
      // const _bottom = getInViewPos(bottom, 'v');
      // const _left = getInViewPos(left, 'h');
      // const _right = getInViewPos(right, 'h');
      // const _height = height * this.viewRatio;
      // const _width = width * this.viewRatio;
      // if ((_bottom - _top) > _height && (_right - _left) > _width) {
      //     return true;
      // }
      // return false;
      var viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
      var viewPortWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
      var top = el.getBoundingClientRect() && el.getBoundingClientRect().top;
      var left = el.getBoundingClientRect() && el.getBoundingClientRect().left;
      return top >= 0 && top <= viewPortHeight && left <= viewPortWidth;
    }
  }, {
    key: "onScroll",
    value: function onScroll() {
      if (this.getCurrUrl() !== this.currUrl) {
        // 页面切换了
        return;
      }

      var isInView = this.isInView(this.el);

      if (!this.isPost && isInView) {
        var data = this.logData.data;

        if (data) {
          this.onLogger(this.logData);
          this.isPost = true;

          if (!this.logConfig.isAlive) {
            // 如果不重复上报,首次上报后即销毁滚动监听
            this.unListenScroll();
          }
        }
      } else if (!isInView && this.logConfig.isAlive) {
        this.isPost = false;
      }
    }
  }, {
    key: "onLogger",
    value: function onLogger(_ref) {
      var event = _ref.event,
          data = _ref.data;
      isDebug && console.log(this.logData);
      var logEvent = baseLogger.logE;
      logEvent(event, data);
    }
  }]);

  return LogScroll;
}();

var $logScroll = null; // 曝光埋点指令

var exposureLogScroll = {
  bind: function bind(el, binding, vnode) {
    if (binding.value) {
      $logScroll = new LogScroll({
        el: el,
        binding: binding,
        vnode: vnode
      });
    }
  },
  inserted: function inserted(el, binding, vnode) {},
  // 当绑定的值有变化时
  update: function update(el, binding, vnode, oldVnode) {},
  unbind: function unbind() {
    $logScroll && $logScroll.unListenScroll();
  }
};

var isDebug$1 = baseFn.fn.getQueryString('__debug');

var LogExposure = /*#__PURE__*/function () {
  function LogExposure(props) {
    var _this = this;

    _classCallCheck(this, LogExposure);

    _defineProperty(this, "isPost", false);

    _defineProperty(this, "options", {
      root: null,
      // 默认为浏览器窗口
      // root: document.querySelector('#app'),
      rootMargin: '0px',
      threshold: 0.5 // 目标dom出现在视图的比例 0 - 1

    });

    _defineProperty(this, "observer", new IntersectionObserver(function (ioes) {
      ioes.forEach(function (ioe) {
        var el = ioe.target;
        var isIntersecting = ioe.isIntersecting;

        if (!_this.isPost && isIntersecting) {
          // 出现在视图
          _this.onLogger(_this.logData);

          _this.isPost = true;

          if (!_this.logConfig.isAlive) {
            _this.observer.unobserve(el);
          }
        } else {
          _this.isPost = false;
        }

        el.onload = el.onerror = function () {
          return _this.observer.unobserve(el);
        };
      });
    }, this.options));

    this.el = props.el;
    this.logData = props.binding.value;
    this.logConfig = Object.assign({
      isAlive: true,
      isRigorous: true
    }, props.binding.arg || {}); // isAlive：是否敏感的，重复上报； isRigorous：是否严谨的，是否首次上报需暴露在视窗内

    if (this.logConfig.isRigorous) {
      this.isInView(props.el);
    } else {
      this.onLogger(this.logData);
    }
  } // 缓存打点数据


  _createClass(LogExposure, [{
    key: "isInView",
    value: function isInView(el) {
      this.observer.observe(el);
    }
  }, {
    key: "onLogger",
    value: function onLogger(_ref) {
      var event = _ref.event,
          data = _ref.data;
      isDebug$1 && console.log(this.logData);
      var logEvent = baseLogger.logE;
      logEvent(event, data);
    }
  }]);

  return LogExposure;
}();

var $logExposure = null; // 曝光埋点指令

var exposureLogObserver = {
  bind: function bind(el, binding, vnode) {
    $logExposure = new LogExposure({
      el: el,
      binding: binding,
      vnode: vnode
    });
  },
  inserted: function inserted(el, binding, vnode) {},
  // 当绑定的值有变化时
  update: function update(el, binding, vnode, oldVnode) {},
  unbind: function unbind(el) {
    $logExposure && $logExposure.observer.unobserve(el);
  }
};

var isSupportIntersectionObserver = ('IntersectionObserver' in window);
var ExposureLogDirective = isSupportIntersectionObserver ? exposureLogObserver : exposureLogScroll; // const ExposureLogDirective = exposureLogScroll;

var install = function install(Vue) {
  Vue.directive('log-exposure', ExposureLogDirective);
};

ExposureLogDirective.install = install;

exports.default = ExposureLogDirective;
