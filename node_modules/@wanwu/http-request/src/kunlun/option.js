import mySentry from '@wanwu/sentry';
import encryption from '@wanwu/im-encryption';
import {
    ua, fn,
} from '@wanwu/base-fn';
// import {
//     encrypt,
//     // KlSignature,
// } from '@wanwu/crypto';
import { getConstID, getUUID, generateUUID, getWebUmidToken, getUAToken } from '@wanwu/mall-web-config';
import { KL_HOSTS, KL_OS_TYPES, ERR_MSGS, AXIOS_ERR_MSGS } from './config';
import {
    getToken,
} from '@wanwu/base-sdk-token-manager';
if (!window.ENCRYPT_KEY) {
    window.ENCRYPT_KEY = {
        appVersion: ua.getAppVersion() || '3.0.2', // 商城
        signVersion: '1.0.0', // h5
        h5sId: '300100',
    };
}

// 重写全局
// window.ENCRYPT_KEY.appVersion = ua.getAppVersion() || '3.0.2';
// const appVer = window.ENCRYPT_KEY.appVersion;
// const signVer = window.ENCRYPT_KEY.signVersion;
// const KlSignatureIns = new KlSignature();
const __env = fn.getQueryString('__env') || 'prod';
const mockUser = fn.getQueryString('mock_user') || '';
const mock = fn.getQueryString('mock') || '';
const kl_debug_params_str = fn.getQueryString('kl_debug_params') || '';
let kl_debug_params = null;
if (kl_debug_params_str) {
    try {
        kl_debug_params = JSON.parse(kl_debug_params_str);
    } catch (e) {
        console.log(e);
    }
}
const protocol = location.protocol.replace(':', '');
const option = {
    requestInterceptor: [
        async (config, option, source) => {
            if (!config.withoutCancelToken) {
                config.cancelToken = source.token;
            } else {
                config.cancelToken = null;
            }
            const appVer = window.ENCRYPT_KEY.appVersion;
            const signVer = window.ENCRYPT_KEY.signVersion;
            const { url, data } = config;
            let osInfo = 'PC';
            if (ua.isIOS()) osInfo = 'IOS';
            if (ua.isAndroid()) osInfo = 'Android';
            const kl_os_type = KL_OS_TYPES[osInfo]; // 操作系统类型 android:1 ios:2 pc:3
            const token = option.getToken();
            const kl_ver = appVer; // 客户端版本
            let kl_token = token; // 用户Token
            const kl_t = parseInt(Date.now() / 1000); // 请求的时间戳，秒级别
            let kl_platform = 3; // 1:app 2:小程序 3:浏览器
            if (ua.isApp()) kl_platform = 1;
            if (ua.isWechatMiniProgram()) kl_platform = 2;
            const kl_display_type = 2; // 展示类型  1:Native 2:H5
            const kl_os_version	= '1.0.0'; // 操作系统版本
            const kl_device_id = await getUUID();
            const kl_trace_id = generateUUID();
            const kl_sign_ver = signVer;
            const kl_sdk_ver = '1.0.3';

            // 请求网关 携带头部信息
            let customHeader = {
                kl_ver,
                kl_token,
                kl_t,
                kl_os_type,
                kl_platform,
                kl_display_type,
                kl_os_version,
                kl_device_id,
                kl_trace_id,
                kl_sign_ver,
                kl_sdk_ver,
                // kl_sign,
            };

            // 设备指纹
            let kl_device_token = '';
            let kl_ua_token = '';
            if (config.fingerprint) {
                try {
                    kl_device_token = await getWebUmidToken();
                    kl_ua_token = await getUAToken();
                } catch (error) {
                    console.log(error);
                }
                customHeader['kl_device_token'] = kl_device_token;
                customHeader['kl_ua_token'] = kl_ua_token;
            }
            // mock
            if (mockUser) customHeader['kl_mock_user'] = mockUser;
            if (mock) customHeader['kl_mock'] = mock;
            // debug params
            if (kl_debug_params) {
                customHeader = {
                    ...customHeader,
                    ...kl_debug_params,
                }
            }
            // 取消上传token
            if (config.withoutToken) {
                delete customHeader['kl_token'];
                kl_token = null;
            }

            // 数据加密
            // if (config.encrypt && (typeof data !== 'undefined')) {
            //     const originText = JSON.stringify(data);
            //     const cipherText = encrypt(originText);
            //     config.data = { cipherText };
            // }

            // 切换host
            let prefix = '';
            let kl_path = '';
            if (!/^http(s)?:\/\//.test(url)) {
                if (!(/^\//.test(url))) {
                    // `/`开头
                    prefix = '/';
                }
                if (__env !== 'useip') {
                    const host = KL_HOSTS[protocol + __env] || KL_HOSTS[__env] || KL_HOSTS.prod;
                    config.url = host + prefix + url;
                } else {
                    const useip = fn.getQueryString('__useip');
                    const useport = fn.getQueryString('__useport');
                    config.url = `http://${useip}:${useport || 8085}` + prefix + url;
                }
                kl_path = prefix + url;
            } else {
                const parseUrlObj = new URL(url);
                kl_path = parseUrlObj.pathname;
            }
            config.data = option.formatData(config.data);

            let kl_sign = '';
            const headerMapKV = [
                ['kl_path', kl_path],
                ['kl_trace_id', kl_trace_id],
                ['kl_token', kl_token],
                ['kl_device_id', kl_device_id],
                ['kl_device_token', kl_device_token],
            ];
            const headerMapKV2 = [];
            headerMapKV.map((item) => {
                if (!item[1]) {
                    delete customHeader[item[0]];
                    return;
                }
                headerMapKV2.push(item);
            });
            const headerMap = new Map(headerMapKV2);
            let signData;
            if (config.data && config.data.kl_data) {
                signData = config.data.kl_data;
            }
            try {
                kl_sign = encryption.sign(kl_t, signData, headerMap);
            } catch (e) {
                console.log(e);
            }

            customHeader['kl_sign'] = kl_sign;
            config.headers.common = Object.assign({}, config.headers.common, customHeader);
            return config;
        },
    ],
    responseInterceptor: [
        (response, option, cancel) => {
            const data = response.data;
            const status = response.status;
            const formatErr = option.formatErr;
            const formatRes = option.formatRes;

            const newError = {
                type: mySentry.ERROR_TYPE.Xhr,
                level: mySentry.ERROR_LEVEL.Info,
                ConfirmReport: (response.config && response.config.ConfirmReport) || null,
            };

            if (status !== 200 && status !== 304) {
                newError.ConfirmReport = true;
                newError.extra = response;
                newError.message = response.message || response.msg || '网络异常';
                return Promise.reject(formatErr(newError));
            }
            if (response.config.skipFilter) {
                return data;
            }
            if (data && data.success) {
                return formatRes(data);
            }
            if (data && (data.code === 301 || data.code === 302)) {
                // 未登录 或 token过期
                // skipLogin是在请求函数中作为第三个参数传递进来的
                if (!response.config.skipLogin) {
                    option.cbFor401(data);
                }
                newError.payload = data;
                newError.message = '未登录';
                // return new Promise((resolve, reject) => {
                //     setTimeout(() => {
                //         reject(formatErr(newError));
                //     }, 3000);
                // });
                return Promise.reject(formatErr(newError));
            }
            newError.payload = data;
            newError.message = data.message || `服务端异常：${data.code}`;
            return Promise.reject(formatErr(newError));
        },
        (err, option) => {
            let msg = '';
            if (err && err.response && ERR_MSGS[err.response.status]) {
                msg = ERR_MSGS[err.response.status];
            }
            err.ConfirmReport = true;
            mySentry.logError(err);
            return Promise.reject(option.formatErr({
                ...err,
                message: AXIOS_ERR_MSGS[err.message] || err.message || msg,
            }));
        },
    ],
    formatRes: res => res.data,
    formatData: data => {
        if (data) return { kl_data: JSON.stringify(data) };
        // if (data) return { kl_data: data };
    },
    getToken: getToken,
};

export default option;
