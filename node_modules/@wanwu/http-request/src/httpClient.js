import httpBase from 'axios';
import merge from 'lodash.merge';
import baseOption from './baseOption';
import { fn } from '@wanwu/base-fn';

class HttpClient {
    constructor(option) {
        this.config = merge({}, baseOption, option);
        this.httpBaseInstance = null;
        this.CancelToken = httpBase.CancelToken;
        this.initSource = this.initSource.bind(this);
        this.cancel = this.cancel.bind(this);
        this.init();
    }

    // 设置请求配置
    setOption(option) {
        this.config = merge({}, this.config, option);
        if (option.requestInterceptor || option.responseInterceptor || option.base) {
            this.init();
        }
    }

    initSource() {
        this.source = this.CancelToken.source();
    }

    cancel() {
        this.source.cancel();
    }

    init() {
        this.httpBaseInstance = httpBase.create({
            ...this.config.base,
        });
        // 依次执行所有配置里的拦截器方法
        this.httpBaseInstance.interceptors.request.use(
            async config => {
                try {
                    if (this.config.requestInterceptor[0] instanceof Array) {
                        for (let i = 0, len = this.config.requestInterceptor[0].length; i < len; i++) {
                            config = await this.config.requestInterceptor[0][i](config, this.config, this.source);
                        }
                        return config;
                    } else {
                        const res = await this.config.requestInterceptor[0](config, this.config, this.source);
                        return res;
                    }
                } catch (error) {
                    console.log(error);
                    return config
                }
            },
            err => {
                return this.config.requestInterceptor[1](err, this.config);
            },
        );
        this.httpBaseInstance.interceptors.response.use(
            async config => {
                const res = await this.config.responseInterceptor[0](config, this.config, this.source.cancel);
                return res;
            },
            err => {
                return this.config.responseInterceptor[1](err, this.config, this.source.cancel);
            },
        );
        this.initSource();
    }

    // 返回请求基类的实例 目前基类使用的是axios
    getHttpBaseInstance() {
        return this.httpBaseInstance;
    }

    get(url, data, config = {}) {
        return this.send('get', url, data, config);
    }

    post(url, data, config = {}) {
        return this.send('post', url, data, config);
    }

    send(method, url, data, config = {}) {
        let params = data;
        return new Promise((resolve, reject) => {
            if ([
                'post',
                'put',
                'patch',
            ].includes(method)) {
                // 兼容 { params:{} } 格式
                let paramsData;
                if (params && params.params && fn.isPlainObject(params.params)) {
                    paramsData = params.params;
                    delete params.params;
                    config = {
                        ...config,
                        ...params,
                    }
                } else {
                    paramsData = params;
                }
                this.httpBaseInstance[method](url, paramsData, {
                    ...config,
                    cancelToken: this.source.token,
                }).then(res => {
                    resolve(res);
                }).catch(error => {
                    this.config.errToast(error);
                    reject(error);
                });
            } else if ([
                'get',
                'delete',
                'head',
            ].includes(method)) {
                this.httpBaseInstance[method](url, {
                    ...paramsData,
                    cancelToken: this.source.token,
                    ...config,
                }).then(res => {
                    resolve(res);
                }).catch(error => {
                    this.config.errToast(error);
                    reject(error);
                });
            } else {
                reject(new Error('请求方法不正确!'));
            }
        });
    }
}

export default HttpClient;
