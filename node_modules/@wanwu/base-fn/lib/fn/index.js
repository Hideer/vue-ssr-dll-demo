"use strict";
/**
 * Create by changsheng on 2019-04-03 11:38
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.clientColor2webColor = exports.colorConvert = exports.pageInitTime = exports.isLargerThanAppVersion = exports.ArrayRemove = exports.getObjDeepValue = exports.typeYalidator = exports.getTypeof = exports.filter = exports.getDebugCode = exports.compareVersion = exports.debounce = exports.throttle = exports.getFormatTimeArray = exports.formatTime = exports.getFormatTime = exports.removeCookie = exports.getCookie = exports.setCookie = exports.removeQueryString = exports.setQueryString = exports.getQueryString = exports.parseUrl = exports.stringifyUrl = exports.stringify = exports.parse = exports.getImageUrl = exports.formatPriceDrawer = exports.formatPrice = exports.omit = exports.pick = exports.flatten = exports.setAt = exports.merge = exports.clone = exports.isEqual = exports.isEqualWithStack = exports.isPromise = exports.isString = exports.isPlainObject = void 0;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;
var slice = Array.prototype.slice;
var isArray = Array.isArray;
var ua = require("./ua");
var VariableTag;
(function (VariableTag) {
    VariableTag["Date"] = "[object Date]";
    VariableTag["Array"] = "[object Array]";
    VariableTag["Object"] = "[object Object]";
})(VariableTag || (VariableTag = {}));
function getTag(value) {
    return Object.prototype.toString.call(value);
}
function isObject(value) {
    return !!value && typeof value === 'object';
}
function isPlainObject(value) {
    return getTag(value) === VariableTag.Object;
}
exports.isPlainObject = isPlainObject;
function isString(value) {
    return typeof value === 'string';
}
exports.isString = isString;
function isPromise(promise) {
    return promise && typeof promise.then === 'function';
}
exports.isPromise = isPromise;
// Shortcut function for checking if an object has a given property directly
// on itself (in other words, not on a prototype).
var has = function (obj, path) {
    if (!Array.isArray(path)) {
        return obj != null && Object.prototype.hasOwnProperty.call(obj, path);
    }
    var length = path.length;
    for (var i = 0; i < length; i++) {
        var key = path[i];
        if (obj == null || !Object.prototype.hasOwnProperty.call(obj, key)) {
            return false;
        }
        obj = obj[key];
    }
    return !!length;
};
var isFunction = function (obj) {
    return typeof obj === 'function';
};
var isEqualWithStack = function (a, b, aStack, bStack) {
    if (aStack === void 0) { aStack = []; }
    if (bStack === void 0) { bStack = []; }
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    // 排除了a = 0, b = -0的情况，因为0 === -0，但是Infinity !== -Infinity
    if (a === b) {
        return a !== 0 || 1 / a === 1 / b;
    }
    // `null` or `undefined` only equal to itself (strict comparison).
    // null === null, undefined !== null，排除a或者b是null的情况
    if (a == null || b == null) {
        return false;
    }
    // `NaN`s are equivalent, but non-reflexive.
    // NaN是非自反的，NaN !== NaN，当a和b都是NaN时，认为他们相等
    if (a !== a && b !== b) {
        return true;
    }
    // Exhaust primitive checks
    // 如果a和b都不是function或者object，则认为他们不相等
    var typeA = typeof a;
    var typeB = typeof b;
    if (typeA !== 'function' && typeA !== 'object' && typeB != 'object') {
        return false;
    }
    // 下面开始对比对象和方法
    // Compare `[[Class]]` names.
    var classNameA = Object.prototype.toString.call(a);
    var classNameB = Object.prototype.toString.call(b);
    if (classNameA !== classNameB) {
        return false;
    }
    switch (classNameA) {
        // Strings, numbers, regular expressions, dates, and booleans are compared by value.
        case '[object RegExp]':
        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
        case '[object String]':
            // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
            // equivalent to `new String("5")`.
            return '' + a === '' + b;
        case '[object Number]':
            // `NaN`s are equivalent, but non-reflexive.
            // Object(NaN) is equivalent to NaN.
            if (+a !== +a)
                return +b !== +b;
            // An `egal` comparison is performed for other numeric values.
            return +a === 0 ? 1 / +a === 1 / b : +a === +b;
        case '[object Date]':
        case '[object Boolean]':
            // Coerce dates and booleans to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a === +b;
        case '[object Symbol]':
            return Symbol.prototype.valueOf.call(a) === Symbol.prototype.valueOf.call(b);
    }
    var areArrays = classNameA === '[object Array]';
    if (!areArrays) {
        // 如果不是数组，但是ab都不是object，那ab不相等
        if (typeof a != 'object' || typeof b != 'object')
            return false;
        // Objects with different constructors are not equivalent, but `Object`s or `Array`s
        // from different frames are.
        // 判断对象的构造函数
        // Array.constructor === Object.constructor，{}.constructor === {}.constructor，Object.constructor === Object.constructor，Object.constructor !== {}.constructor
        var aCtor = a.constructor;
        var bCtor = b.constructor;
        // 两者的构造函数不同，并且两者都不是`Object` or `Array`
        if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && ('constructor' in a && 'constructor' in b)) {
            return false;
        }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    // 避免循环引用，递归的时候出现死循环
    var aStackLength = aStack.length;
    var bStackLength = bStack.length;
    while (aStackLength--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        // 遇到循环引用，直接比较对象自身和上一级对象，发现相等，就是循环引用，直接跳出递归
        if (aStack[aStackLength] === a && bStack[aStackLength] === b)
            return true;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    // 遍历数组
    if (areArrays) {
        // Compare array lengths to determine if a deep comparison is necessary.
        var lengthA = a.length;
        var lengthB = b.length;
        // 数组顺序都不相等，就肯定不相等了
        if (lengthA !== lengthB)
            return false;
        // Deep compare the contents, ignoring non-numeric properties.
        // 递归，这递归写的真丑
        while (lengthA--) {
            if (!exports.isEqualWithStack(a[lengthA], b[lengthA], aStack, bStack))
                return false;
        }
    }
    else {
        // Deep compare objects.
        // 遍历对象
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        var keysALength = keysA.length;
        var keysBLength = keysB.length;
        // Ensure that both objects contain the same number of properties before comparing deep equality.
        if (keysALength !== keysBLength)
            return false;
        // 递归，这递归写的真丑
        while (keysALength--) {
            // Deep compare each member
            var key = keysA[keysALength];
            if (!(has(b, key) && exports.isEqualWithStack(a[key], b[key], aStack, bStack)))
                return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
};
exports.isEqualWithStack = isEqualWithStack;
/**
 * 判断变量是否相等
 * @param  {any} a     需要比较的变量
 * @param  {any} b     需要比较的变量
 * @return {Boolean}   变量是否相等
 */
var isEqual = function (a, b) {
    return exports.isEqualWithStack(a, b);
};
exports.isEqual = isEqual;
/**
 * deep copy
 * @param value
 * @return {any}
 */
function clone(value) {
    if (value === null) {
        return value;
    }
    if (typeof value in ['number', 'string', 'boolean', 'undefined']) {
        return value;
    }
    switch (getTag(value)) {
        case VariableTag.Date:
            return new Date(value);
        case VariableTag.Array:
            return value.map(clone);
        case VariableTag.Object:
            return merge({}, value);
        default:
            return value;
    }
}
exports.clone = clone;
/**
 * deep merge
 * @param {{}} dest
 * @param sources
 * @return {{}}
 */
function merge(dest) {
    if (dest === void 0) { dest = {}; }
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    if (sources.length === 0) {
        return dest;
    }
    for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {
        var source = sources_1[_a];
        if (source === dest) {
            continue;
        }
        if (!isPlainObject(source)) {
            continue;
        }
        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                dest[key] = clone(source[key]);
            }
        }
    }
    return dest;
}
exports.merge = merge;
function setAt(path, root, data) {
    if (!path) {
        return;
    }
    var parts = path.replace(/\[([^\]]+)]/g, '.$1') // Replace 'x[0]' to 'x.0'
        .split('.').map(function (part) {
        return part.replace(/['"`]/g, '');
    });
    var p = root;
    while (true) {
        var part = parts.shift();
        try {
            if (parts.length === 0) {
                p[part] = data;
                break;
            }
            p = p[part];
        }
        catch (err) {
            throw new Error('fail to set value on path ' + path);
        }
    }
}
exports.setAt = setAt;
/**
 * 数组扁平化
 * @param array
 * @return {any}
 */
function flatten(array) {
    return array.reduce(function (result, item) {
        if (isArray(item)) {
            return result.concat(item);
        }
        result.push(item);
        return result;
    }, []);
}
exports.flatten = flatten;
function basePick(object, keys) {
    var picked = {};
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        if (hasOwnProperty.call(object, key)) {
            picked[key] = object[key];
        }
    }
    return picked;
}
/**
 * 从对象里取数据，返回取的对象
 * @param object
 * @param keys
 * @return {{}}
 */
function pick(object) {
    var keys = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        keys[_i - 1] = arguments[_i];
    }
    return basePick(object, flatten(keys));
}
exports.pick = pick;
/**
 * 从多想去除数据，返回去除之后的对象
 * @param object
 * @param keys
 * @return {{}}
 */
function omit(object) {
    var keys = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        keys[_i - 1] = arguments[_i];
    }
    keys = flatten(keys);
    return basePick(object, Object.keys(object).filter(function (key) {
        return keys.indexOf(key) < 0;
    }));
}
exports.omit = omit;
/**
 * 价格格式化
 * @param price
 * @return {string}
 */
function formatPrice(price) {
    if (!price && price !== 0) {
        return '';
    }
    else if (typeof price === 'string') {
        return price;
    }
    else {
        return (price / 100).toFixed(2);
    }
}
exports.formatPrice = formatPrice;
function formatPriceDrawer(price, fractionDigits) {
    if (!price && price !== 0) {
        return '';
    }
    else if (typeof price === 'string') {
        return price;
    }
    else {
        if (price % 100 === 0) {
            return (price / 100).toFixed(0);
        }
        else if (price % 10 === 0) {
            return (price / 100).toFixed(1);
        }
        else {
            return (price / 100).toFixed(2);
        }
    }
}
exports.formatPriceDrawer = formatPriceDrawer;
/**
 * 取原图地址
 * @param path
 * @return {any}
 */
function getImageUrl(path) {
    if (path.indexOf('/') === 0) {
        return 'http://cdn.wanwudezhi.com' + path;
    }
    else {
        return path;
    }
}
exports.getImageUrl = getImageUrl;
/**
 * 解析query字符串，返回KV对象
 * @param queryString
 * @param decode
 * @return {{}}
 */
function parse(queryString, decode) {
    if (decode === void 0) { decode = true; }
    var query = {};
    if (!queryString) {
        return query;
    }
    var queryArray = queryString.split('&');
    for (var _i = 0, queryArray_1 = queryArray; _i < queryArray_1.length; _i++) {
        var queryItem = queryArray_1[_i];
        var arr = queryItem.split('=');
        if (arr.length > 1) {
            if (typeof query[arr[0]] === 'undefined') {
                query[arr[0]] = decode ? decodeURIComponent(arr[1]) : arr[1];
            }
        }
    }
    return query;
}
exports.parse = parse;
/**
 * 格式化对象，组成url的query，key=value&key1=value1
 * @param params
 * @param {boolean} encode
 * @return {string}
 */
function stringify(params, encode) {
    if (encode === void 0) { encode = true; }
    if (!params) {
        return '';
    }
    return Object.keys(params).map(function (key) {
        var value = params[key];
        return stringifyKV(key, value, encode);
    }).filter(function (image) {
        return image !== '';
    }).join('&');
}
exports.stringify = stringify;
function stringifyKV(key, value, encode) {
    if (typeof value === 'undefined') {
        return '';
    }
    if (value === null) {
        return '';
    }
    if (typeof value === 'string') {
        value = encode ? encodeURIComponent(value) : value;
    }
    return key + '=' + value;
}
/**
 * 格式化URL，将对象拼到url上
 * @param url
 * @param params
 * @param {boolean} encode
 * @return {string}
 */
function stringifyUrl(url, params, encode) {
    if (params === void 0) { params = {}; }
    if (encode === void 0) { encode = true; }
    // 从url取的数据，一定需要decode
    var parsedUrl = parseUrl(url, params, true);
    var path = parsedUrl.path;
    var mergedParams = parsedUrl.params;
    if (Object.keys(mergedParams).length === 0) {
        return path;
    }
    else {
        return path + '?' + stringify(mergedParams, encode);
    }
}
exports.stringifyUrl = stringifyUrl;
function parseUrl(url, params, decode) {
    if (params === void 0) { params = {}; }
    if (decode === void 0) { decode = true; }
    var baseUrlArr = url.split('#');
    url = baseUrlArr[0];
    var hash = baseUrlArr[1];
    var arr = url.split('?');
    var path = arr[0];
    if (arr.length > 0) {
        params = Object.assign({}, parse(arr[1], decode), params);
    }
    return { path: path, params: params, hash: hash };
}
exports.parseUrl = parseUrl;
/**
 * @desc 获取链接参数的值
 * @param  {string} name - 参数名字
 * @param  {string} [url] - 链接url，为空的时候取location.search
 * @return {string} 参数
 */
function getQueryString(name, url) {
    if (url === void 0) { url = location.search; }
    if (!name)
        return '';
    url = url.split('#')[0];
    var reg = new RegExp('(^|\\?|&)' + name + '=([^&]*)(&|$)', 'i');
    var matches = url.match(reg);
    if (matches) {
        return decodeURIComponent(matches[2]);
    }
    return reg.test(url) ? RegExp.$2.replace(/\+/g, ' ') : '';
}
exports.getQueryString = getQueryString;
/**
 * 设置链接参数
 * @param uri 要设置的链接
 * @param key 要设置的参数 key
 * @param value 要设置的值 value
 */
function setQueryString(uri, key, value) {
    var re = new RegExp('([?&])' + key + '=.*?(&|#|$)', 'i');
    var separator = uri.indexOf('?') !== -1 ? '&' : '?';
    if (uri.match(re)) {
        return uri.replace(re, '$1' + key + '=' + value + '$2');
    }
    else {
        return uri + separator + key + '=' + value;
    }
}
exports.setQueryString = setQueryString;
/**
 * 删除链接参数
 * @param uri
 * @param key
 */
function removeQueryString(uri, key) {
    var re = new RegExp('([?&])' + key + '=.*?(&|#|$)', 'i');
    var separator = uri.indexOf('?') !== -1 ? '&' : '?';
    var uriRes = uri;
    while (uriRes.match(re)) {
        if (RegExp.$1 === '&') {
            uriRes = uriRes.replace(re, '$2');
        }
        else {
            uriRes = uriRes.replace(re, '$1');
        }
    }
    return uriRes;
}
exports.removeQueryString = removeQueryString;
/**
 * 设置 cookie
 *
 * demo: M.setCookie('_ccna', 2, {expire: 1, path: '/'});
 * @desc 设置cookie值，只能设置二级域名，过期时间最多一天
 * @param {string} name - cookie name
 * @param {string} value - cookie value
 * @param {object} options
 *          options.expire: 过期时间，单位为天
 *          options.path:   cookie 存放路径
 */
function setCookie(name, value, options) {
    if (options === void 0) { options = {}; }
    if (value === null || typeof value === 'undefined') {
        value = '';
        options.expires = -1;
    }
    var expires = '';
    if (options.expires && (typeof options.expires == 'number' || options.expires.toUTCString)) {
        var date = new Date();
        var dayTimes = 86400000;
        var times = date.getTime() + dayTimes;
        if (options.expires.getTime) {
            times = options.expires.getTime();
        }
        else if (Number(options.expires)) {
            //清除cookie
            times = date.getTime() + options.expires * dayTimes;
        }
        date.setTime(times);
        expires = '; expires=' + date;
    }
    var path = options.path ? '; path=' + (options.path) : '';
    var secure = options.secure ? '; secure' : '';
    var domain = '';
    //用户只能设置二级域名
    if (options.domain && options.domain.toString().split('.').length >= 3) {
        domain = '; domain=' + (options.domain);
    }
    else {
        domain = '; domain=' + document.domain.toString();
    }
    document.cookie = [name, '=', encodeURIComponent(value), expires, path, domain, secure].join('');
}
exports.setCookie = setCookie;
/**
 * 获取 cookie 值, 如果 cookie 取不到，返回 '';
 * @param  {string} name - cookie name
 * @return {string} cookie value
 */
function getCookie(name) {
    var arr = document.cookie.match(new RegExp('(^| )' + name + '=([^;]*)(;|$)'));
    if (arr !== null)
        return decodeURIComponent(arr[2]);
    return '';
}
exports.getCookie = getCookie;
/**
 * 删除 cookie
 */
function removeCookie(name, options) {
    options = options || {};
    options.expires = -1;
    this.setCookie(name, null, options);
}
exports.removeCookie = removeCookie;
/**
 * 补全数字
 * @param  {Number} val 数字
 * @return {String}     数字字符串
 */
function completeZero(val) {
    return val < 10 ? "0" + val : val;
}
/**
 * 获取格式化时间
 * @param  {Number} leftSecond 剩余时间
 * @param  {String} format      格式
 * @return {Object}             格式化映射对象
 */
function getFormatTime(leftSecond, format) {
    var z = leftSecond % 1000;
    leftSecond = Math.floor(leftSecond / 1000);
    var d = Math.floor(leftSecond / (60 * 60 * 24));
    var h = Math.floor((leftSecond - d * 24 * 60 * 60) / 3600);
    var m = Math.floor((leftSecond - (d * 24 * 60 + h * 60) * 60) / 60);
    var s = Math.floor(leftSecond - (d * 24 * 60 + h * 60 + m) * 60);
    if (leftSecond >= 86400 && format.indexOf('d') === -1) {
        h += d * 24;
    }
    if (leftSecond >= 3600 && format.indexOf('h') === -1) {
        m += h * 60;
    }
    if (leftSecond >= 60 && format.indexOf('m') === -1) {
        s += m * 60;
    }
    return {
        dd: completeZero(d),
        hh: completeZero(h),
        mm: completeZero(m),
        ss: completeZero(s),
        zz: completeZero(z),
        zzz: z < 100 ? '0' + completeZero(z) : z,
        d: d,
        h: h,
        m: m,
        s: s,
        z: z,
    };
}
exports.getFormatTime = getFormatTime;
/**
 * 时间格式化（非日期），如果没雨dd或者d，会将时间加到小时中，没有hh或者h，把时间加到分钟，以此类推
 * @param  {Number} timeStamp 时间
 * @param  {String} format    格式
 * @return {[type]}
 * @example   formatTimeStamp(60, 'mm分ss秒') === 01分00秒
 * @example   formatTimeStamp(60, 'ss秒') === 60秒
 */
function formatTime(timeStamp, format) {
    if (format === void 0) { format = 'dd hh:mm:ss'; }
    var timeObj = getFormatTime(timeStamp, format);
    return format.replace(/([a-z])(\1)*/ig, function (m) {
        return timeObj[m];
    });
}
exports.formatTime = formatTime;
function getFormatTimeArray(timeStamp, format) {
    if (format === void 0) { format = 'dd hh:mm:ss'; }
    var timeObj = getFormatTime(timeStamp, format);
    return format.match(/[\u4e00-\u9fa5]+|[^a-zA-Z]|([a-z])(\1)?/g).map(function (item) {
        if (/([a-z])(\1)?/.test(item)) {
            return {
                value: timeObj[item],
                type: 'number',
            };
        }
        else {
            return {
                value: item,
                type: 'symbol',
            };
        }
    });
}
exports.getFormatTimeArray = getFormatTimeArray;
function apply(func, thisArg, args) {
    if (typeof args === 'undefined') {
        return func.call(thisArg);
    }
    switch (args.length) {
        case 0:
            return func.call(thisArg);
        case 1:
            return func.call(thisArg, args[0]);
        case 2:
            return func.call(thisArg, args[0], args[1]);
        case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        default:
            return func.apply(thisArg, args);
    }
}
/**
 * 节流函数，保证方法至少间隔wait时间执行一次
 * @param {(...args: any[]) => any} func
 * @param {number} wait
 * @param {{leading?: boolean; trailing?: boolean}} options
 * @return {(...args: any[]) => any}
 */
function throttle(func, wait, options) {
    if (options === void 0) {
        options = {};
    }
    var context;
    var args;
    var result;
    var timeout = null;
    var previous = 0;
    var later = function () {
        previous = options.leading === false ? 0 : Date.now();
        timeout = null;
        result = apply(func, context, args);
        if (!timeout) {
            context = args = null;
        }
    };
    var throttled = function () {
        var now = Date.now();
        if (!previous && options.leading === false) {
            previous = now;
        }
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
            /**
             * when client time is set forward, remaining may be negative
             * while timeout is not null
             */
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = now;
            result = apply(func, context, args);
            /**
             * fix throttle and debounce to be re-entrant #1629
             * @see {@link https://github.com/jashkenas/underscore/pull/1629}
             */
            if (!timeout) {
                context = args = null;
            }
        }
        else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
        }
        return result;
    };
    throttled.cancel = function () {
        clearTimeout(timeout);
        previous = 0;
        timeout = context = args = null;
    };
    return throttled;
}
exports.throttle = throttle;
/**
 * 防抖函数，保证方法在上次调用之后wait时间之后执行
 * @param {(...args: any[]) => any} func
 * @param {number} wait
 * @param {boolean} immediate
 * @return {(...args: any[]) => any}
 */
function debounce(func, wait, immediate) {
    var timeout;
    var args;
    var context;
    var timestamp;
    var result;
    var later = function () {
        var last = Date.now() - timestamp;
        if (last < wait && last > 0) {
            timeout = setTimeout(later, wait - last);
        }
        else {
            timeout = null;
            if (!immediate) {
                result = func.apply(context, args);
                if (!timeout) {
                    context = args = null;
                }
            }
        }
    };
    var debounced = function () {
        context = this;
        args = arguments;
        timestamp = Date.now();
        var callNow = immediate && !timeout;
        if (!timeout) {
            timeout = setTimeout(later, wait);
        }
        if (callNow) {
            result = func.apply(context, args);
            context = args = null;
        }
        return result;
    };
    debounced.cancel = function () {
        clearTimeout(timeout);
        timeout = null;
    };
    return debounced;
}
exports.debounce = debounce;
/**
 * 语义化版本号比较
 * @param {string} v1
 * @param {string} v2
 * @return {number}
 */
function compareVersion(v1, v2) {
    if (!v1 || !v2) {
        return -1;
    }
    var v1Arr = v1.split('.');
    var v2Arr = v2.split('.');
    var len = Math.max(v1Arr.length, v1Arr.length);
    while (v1Arr.length < len) {
        v1Arr.push('0');
    }
    while (v2Arr.length < len) {
        v2Arr.push('0');
    }
    for (var i = 0; i < len; i++) {
        var num1 = parseInt(v1Arr[i]);
        var num2 = parseInt(v2Arr[i]);
        if (num1 > num2) {
            return 1;
        }
        else if (num1 < num2) {
            return -1;
        }
    }
    return 0;
}
exports.compareVersion = compareVersion;
function getDebugCode() {
    var today = new Date();
    var month = today.getMonth() + 1;
    var day = today.getDate();
    var digit = day % 10;
    var tmp = Math.floor(month / 10);
    var code = '' + (tmp + digit + 7) % 10;
    tmp = month % 10;
    code = code + (tmp + digit + 7) % 10;
    tmp = Math.floor(day / 10);
    code = code + (tmp + digit + 7) % 10;
    tmp = day % 10;
    code = code + (tmp + digit + 7) % 10;
    return code;
}
exports.getDebugCode = getDebugCode;
function filter(data, filterCallback) {
    if (isArray(data)) {
        return Array.prototype.filter.call(data, filterCallback);
    }
    else {
        var result = {};
        for (var _i = 0, _a = Object.keys(data); _i < _a.length; _i++) {
            var key = _a[_i];
            var value = data[key];
            if (filterCallback.call(null, value, key)) {
                result[key] = value;
            }
        }
        return result;
    }
}
exports.filter = filter;
function getTypeof(obj) {
    switch (obj) {
        case null:
            return "null";
        case undefined:
            return "undefined";
    }
    var s = Object.prototype.toString.call(obj);
    switch (s) {
        case "[object String]":
            return "string";
        case "[object Number]":
            return "number";
        case "[object Boolean]":
            return "boolean";
        case "[object Array]":
            return "array";
        case "[object Date]":
            return "date";
        case "[object Function]":
            return "function";
        case "[object RegExp]":
            return "regExp";
        case "[object Object]":
            return "object";
        default:
            return "object";
    }
}
exports.getTypeof = getTypeof;
/**
 * 判断各种js数据类型
 */
exports.typeYalidator = {
    /**
     * 判断是否是字符串
     * @param value
     * @returns {boolean}
     */
    isString: function (value) {
        return typeof value === "string";
    },
    /**
     * 判断是否是 number
     * @param value
     * @returns {boolean}
     */
    isNumber: function (value) {
        return typeof value === "number";
    },
    /**
     * 判断是否是NaN
     * @param value
     * @returns {boolean}
     */
    isNaN: function (value) {
        return typeof value === "number" && value.toString() === "NaN";
    },
    /**
     * 判断是否是整形数字
     * @param value
     * @returns {boolean}
     */
    isInt: function (value) {
        value = value < 0 ? Math.abs(value) : value;
        return this.isNumber(value) && value % 1 === 0;
    },
    /**
     * 判断是否浮点型数字
     * @param value
     * @returns {boolean}
     */
    isFloat: function (value) {
        value = value < 0 ? Math.abs(value) : value;
        return this.isNumber(value) && value % 1 !== 0;
    },
    /**
     * 判断是否是bool型数据
     * @param value
     * @returns {boolean}
     */
    isBool: function (value) {
        return typeof value === "boolean";
    },
    /**
     * 判断是否是 undefined
     * @param value
     * @returns {boolean}
     */
    isUndefined: function (value) {
        return typeof value === "undefined";
    },
    /**
     * 判读是否是function
     * @param value
     * @returns {boolean}
     */
    isFunction: function (value) {
        return typeof value === "function";
    },
    /**
     * 判断是否是数组
     * @param value
     * @returns {boolean}
     */
    isArray: function (value) {
        return Object.prototype.toString.call(value) === '[object Array]';
    },
    /**
     * 判断是否是对象
     * @param value
     * @returns {boolean}
     */
    isObject: function (value) {
        return Object.prototype.toString.call(value) === '[object Object]';
    },
    /**
     * 判断是否是null
     * @param value
     * @returns {boolean}
     */
    isNull: function (value) {
        return Object.prototype.toString.call(value) === '[object Null]';
    },
    /**
     * 判断值是否为空
     * @param value
     * @return {boolean}
     */
    isEmpty: function (value) {
        if (this.isObject(value) || this.isArray(value)) {
            return Object.keys(value).length === 0;
        }
        return value === "" || this.isNaN(value) || this.isUndefined(value) || this.isNull(value);
    },
};
/**
 *  获取对象或者数组的深值，避免空指针
 * @param obj 对象
 * @param valuePath exa:'detail.0.0' 对象值得路径
 */
var getObjDeepValue = function (obj, valuePath) {
    if (/(undefind|null)/.test(getTypeof(obj))) {
        return undefined;
    }
    var valuePathArr = valuePath.split('.');
    var curValue = obj;
    for (var _i = 0, valuePathArr_1 = valuePathArr; _i < valuePathArr_1.length; _i++) {
        var pathItem = valuePathArr_1[_i];
        curValue = curValue[pathItem];
        if (!curValue) {
            return undefined;
        }
    }
    return curValue;
};
exports.getObjDeepValue = getObjDeepValue;
/**
 * 数组item remove方法
 * @param {Array} arr
 * @param {*} item [数组要删除的item]
 */
var ArrayRemove = function (arr, item) {
    if (!arr.length)
        return [];
    var index = arr.indexOf(item);
    if (index > -1) {
        arr.splice(index, 1);
        return arr;
    }
    return arr;
};
exports.ArrayRemove = ArrayRemove;
var isLargerThanAppVersion = function (appVersion) {
    return ua.isApp() && compareVersion(ua.getAppVersion(), appVersion) >= 0;
};
exports.isLargerThanAppVersion = isLargerThanAppVersion;
/**
 * 2021-05-08 新增计算页面白屏时间方法 - 银时
 */
var pageInitTime = function () {
    // 在不支持getEntriesByType()的情况下，使用timing
    var whiteScreenTime = performance.timing.domInteractive - performance.timing.navigationStart;
    // 支持getEntriesByType()，没有domLoading时机，所以实用domInteractive
    if (performance.getEntriesByType && performance.getEntriesByType('paint').length) {
        var paintList = performance.getEntriesByType('paint');
        paintList.map(function (item) {
            if (item.name === 'first-contentful-paint') {
                whiteScreenTime = item.startTime;
            }
        });
    }
    return whiteScreenTime;
};
exports.pageInitTime = pageInitTime;
// 2021-05-11 16进制颜色和rgba互换 - 慕辰
// 处理16进制的带有透明度的颜色格式在部分手机不支持的问题；
// css规范建议：带有透明度的16进制颜色格式通过 rgba 的形式处理；
var colorConvert = function (color) {
    if (typeof color !== 'string')
        return color;
    var r;
    var g;
    var b;
    var a;
    if (color.startsWith('#') && color.length === 9) {
        r = parseInt(color[1] + color[2], 16);
        g = parseInt(color[3] + color[4], 16);
        b = parseInt(color[5] + color[6], 16);
        a = parseFloat((parseInt(color[7] + color[8], 16) / 255).toFixed(2));
        return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
    }
    else if (color.startsWith('rgba')) {
        var pColor = color.match(/(\d(\.\d+)?)+/g);
        if (pColor.length !== 4) {
            return color;
        }
        r = Number(pColor[0]).toString(16);
        g = Number(pColor[1]).toString(16);
        b = Number(pColor[2]).toString(16);
        a = Number(Math.round(Number(pColor[3]) * 255)).toString(16);
        r = r.length === 2 ? r : '0' + r;
        g = g.length === 2 ? g : '0' + g;
        b = b.length === 2 ? b : '0' + b;
        a = a.length === 2 ? a : '0' + a;
        return '#' + r + g + b + a;
    }
    else {
        return color;
    }
};
exports.colorConvert = colorConvert;
// 2021-05-12 客户端16进制颜色转web颜色处理 - 慕辰
// 客户端的16进制的颜色格式：前两位为透明度，后面跟的六位为色码；
// web端的颜色格式格式：前六位为色码，后两位为透明度；
// 带有透明度的16进制颜色格式通过 rgba 的形式处理；
var clientColor2webColor = function (color) {
    if (typeof color !== "string")
        return color;
    if (color.startsWith('#') && color.length === 9) {
        // const colorReg = /(?<opacity>[0-9a-fA-F]{2})(?<colorVal>[0-9a-fA-F]{6})/g;
        // const colorGroup = colorReg.exec(color).groups;
        // const { opacity, colorVal } = colorGroup;
        var opacity = color.slice(1, 3);
        var colorVal = color.slice(3, 9);
        return exports.colorConvert("#" + colorVal + opacity);
    }
    else {
        return color;
    }
};
exports.clientColor2webColor = clientColor2webColor;
