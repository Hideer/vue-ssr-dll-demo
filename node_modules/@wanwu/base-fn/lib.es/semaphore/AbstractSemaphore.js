import { __awaiter } from "tslib";
import BaseLock from './BaseLock';
import { DEFAULT_LOCKER_NAME } from './Canstant';
export default class AbstractSemaphore extends BaseLock {
    constructor(name = DEFAULT_LOCKER_NAME, fair = false) {
        super();
        this.fair = fair;
        this.name = name;
    }
    acquire(permits = 1, index = -1) {
        // @ts-ignore
        return new Promise((resolve, reject) => {
            if (this.fair) {
                this.insertTask({ resolve, reject, permits }, index);
                this.executeTaskQueue();
            }
            else {
                this.acquireUnfair(permits, resolve, reject, index);
            }
        });
    }
    acquireUnfair(permits, resolve, reject, index) {
        this.doAcquire(permits).then((success) => {
            if (success) {
                resolve(true);
            }
            else {
                this.insertTask({ resolve, reject, permits }, index);
                // this.executeTaskQueue();
            }
        }).catch((error) => {
            reject(error);
        });
    }
    release(permits = 1) {
        return this.doRelease(permits).then(() => {
            this.executeTaskQueue();
            return true;
        });
    }
    tryAcquire(permits = 1, timeout) {
        // @ts-ignore
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (timeout > 0) {
                    let endTime = new Date().getTime() + timeout;
                    let success = false;
                    // 期间一直重试
                    do {
                        success = yield this.doAcquire(permits);
                    } while (new Date().getTime() <= endTime && !success);
                    resolve(success);
                }
                else {
                    resolve(yield this.doAcquire(permits));
                }
            }
            catch (error) {
                reject(error);
            }
        }));
    }
    executeTaskQueue() {
        // 按序执行之前缓存的任务
        if (this.getTaskLength() > 0) {
            const { resolve, reject, permits } = this.shiftTask();
            this.acquireUnfair(permits, resolve, reject, 0);
        }
    }
}
