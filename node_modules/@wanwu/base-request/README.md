# axios的一个简单配置

## axios封装

本方法是对axios的一个基本的小封装，一些配置是参考mall-web和mall-admin两个项目对其进行设置的。

## 基本用法

首先传入一些基本配置

```javascript
import Axios from '@wanwu/base-request';
...
let instance = new Axios(option);
return instance.sendAxios;
```

## 配置项

上面的option配置项参数

| 参数   |      说明      |  类型 |  可选值 |  默认值 |
|----------|:-------------:|:-------------:|:-------------:|------:|
| base  |  create axios实例传入参数 | Object |  - |  -  |
| getToken |    获取token的方法   |   Function |  -  |  () => sessionStorage.getItem('token')  |
| tokenKey | 将token给header的属性 |    String |  -  |  Authorization  |
| successCode | 请求成功的code组 |    Array |  -  |  [ 1001 ]  |
| errToast | 请求失败的弹出提示操作 |    Function(error) |  -  |  -  |
| cbFor401 | 401时的回调，本方法会在responseInterceptor默认的第一<br>个方法中执行 |    Function(data) |  -  |  -  |
| formatErr | 在拦截器中抛出错误之前预处理错误，本方法会在requestInterceptor<br>和responseInterceptor的默认方法中执行 |    Function(error) |  -  |  -  |
| formatRes | 在请求成功时预处理返回值，本方法会在responseInterceptor<br>默认的第一个方法中执行  |    Function(data) |  -  |  -  |
| formatData | 处理请求参数，会在sendAxios内执行  |    Function(data) |  -  |  -  |
| requestInterceptor | 请求拦截器传入方法数组 |    Array[Function, Function] |  -  |  默认值在下面  |
| responseInterceptor | 响应拦截器传入方法数组  |    Array[Function, Function] |  -  |  默认值在下面  |


requestInterceptor默认值

```javascript
[
	(config, option) => {
		const token = option.getToken();
		const tokenKey = option.tokenKey || 'Authorization';
		if (token) {
			// 这里将token设置到headers中，header的key是token，这个key值根据你的需要进行修改即可
			config.headers[tokenKey] = token;
		}
		return config;
	},
	(err, option) => Promise.reject(option.formatErr(err))
]
```
responseInterceptor默认值

```javascript
[
	(response, option, cancel) => {
		const data = response.data;
		const status = response.status;
		const xhrResponseTime = Date.now() - response.config.headers.requestTime;
		const requestUrl = response.config.url;
		const formatErr = option.formatErr;
		const formatRes = option.formatRes;
		const code = typeof data.code === 'number' 

		let newError = mySentry.setMySentryError({
			type: mySentry.ERROR_TYPE.Xhr,
			level: mySentry.ERROR_LEVEL.Info,
			ConfirmReport: (response.config && response.config.ConfirmReport) || null,
		});

		if (status === 200 || status === 304) {
			const logExt = { xhrResponseTime, requestUrl };
			logE(20003, logExt);
			if (response.config.skipFilter) {
				return formatRes(data);
			} else if (option.successCode.includes(data.code)) {
				// 请求成功
				// } else if (data && (data.success && data.code === 1001)) {
				return formatRes(data);
			} else if (data && data.code === 4001) {
				// 未登录
				// @ts-ignore
				// 这里的skipLogin是在请求函数中作为第三个参数传递进来的
				if (!response.config.skipLogin) {
					cancel(); // 取消其他正在进行的请求
					option.cbFor401(data);
				}
				newError.message = '未登录';
				return Promise.reject(formatErr(newError));
				// return Promise.reject(newError);
			} else {
				Object.assign(newError, { payload: data, message: data.message });
				return Promise.reject(formatErr(newError));
			}
		} else {
			let error = { ConfirmReport: true, extra: response, message: response.message || response.msg || '网络异常' };
			return Promise.reject(formatErr(error));
		}
	},
	(err, option) => {
		// 对响应错误做点什么
		let msg = '';
		if (err && err.response) {
			switch (err.response.status) {
			case 400: msg = '请求错误(400)'; break;
			case 401: msg = '未授权，请重新登录(401)'; break;
			case 403: msg = '拒绝访问(403)'; break;
			case 404: msg = '未找到此接口(404)'; break;
			case 408: msg = '请求超时(408)'; break;
			case 500: msg = '服务器错误(500)'; break;
			case 501: msg = '服务未实现(501)'; break;
			case 502: msg = '网络错误(502)'; break;
			case 503: msg = '服务不可用(503)'; break;
			case 504: msg = '网络超时(504)'; break;
			case 505: msg = 'HTTP版本不受支持(505)'; break;
			default: msg = `连接出错(${err.response.status})!`;
			}
		}else{
			msg = '连接服务器失败!';
		}
		return Promise.reject(option.formatErr({
			...err,
			ConfirmReport: true,
			message: msg || '请求失败',
		}));
	}
]
```

此配置仅限参考

## 原型方法介绍
initSource： 在后端返回4001后，如果没有skipLogin，响应拦截器默认的第一个方法会将后续请求的响应操作拦截掉，如果页面没有刷新，在重新登录前应调用一次initSource重置axios的CancelToken(参考mall-web)

initAxios： 在创建实例时会默认调用，其中对axios做了拦截器配置

sendAxios： 实际使用中调用的方法，对一些传参做了格式兼容，使用示例如下

## 实际使用

```javascript
import sendAxios from 'util/axios';
...
sendAxios('get', url, { name: 'lisi' }, { skipLogin: true }).then(res => {}, rej => {});
sendAxios('post', url, { name: 'lisi' }, { skipLogin: false }).then(res => {}, rej => {});
sendAxios('delete', url, { name: 'lisi' }, { withoutToken: true }).then(res => {}, rej => {});
sendAxios('put', url, { name: 'lisi' }, { withoutToken: false }).then(res => {}, rej => {});

```


### 定制部分

因mall-web中部分js组件直接引入了request方法，为了方便之后拆分这些js包时可以少些一些配置代码，所以目前针对mall-web项目单独配置了一份代码