/*
 * @Descripttion:
 * @version: 0.0.0
 * @Author: fenghe
 * @Date: 2019-11-28 15:29:29
 * @LastEditors  : fenghe
 */
import axios from 'axios';
import merge from 'lodash.merge';
import baseOption from './baseOption';
// let qs = require('qs');
// 解决中文乱码


class Request {
    constructor(option) {
        this.config = merge({}, baseOption, option);
        this.instance = null;
        this.CancelToken = axios.CancelToken;
        this.source = this.CancelToken.source();
        this.initAxios = this.initAxios.bind(this);
        this.initSource = this.initSource.bind(this);
        this.cancel = this.cancel.bind(this);
        this.sendAxios = this.sendAxios.bind(this);
        this.initAxios();
    }

    setOption(option) {
        this.config = merge({}, this.config, option);
        if (option.requestInterceptor || option.responseInterceptor) this.initAxios();
    }

    pushInterceptorsSuccess(fun) {
        if (typeof fun !== 'function') return;
        if (this.config.requestInterceptor[0] instanceof Array) {
            this.config.requestInterceptor[0].push(fun);
        } else {
            const originRequestInterceptor = this.config.requestInterceptor[0];
            this.config.requestInterceptor[0] = [originRequestInterceptor, fun];
        }
        this.initAxios();
    }

    initSource() {
        this.source = this.CancelToken.source();
    }

    cancel() {
        this.source.cancel();
    }

    initAxios() {
        this.instance = axios.create({
            ...this.config.base,
        });
        this.instance.interceptors.request.use(
            async config => {
                try {
                    if (this.config.requestInterceptor[0] instanceof Array) {
                        for (let i = 0, len = this.config.requestInterceptor[0].length; i < len; i++) {
                            config = await this.config.requestInterceptor[0][i](config, this.config, this.source);
                        }
                        return config;
                    } else {
                        const res = await this.config.requestInterceptor[0](config, this.config, this.source);
                        return res;
                    }
                } catch (error) {
                    console.log(error);
                    return config
                }
            },
            err => {
                return this.config.requestInterceptor[1](err, this.config);
            },
        );
        this.instance.interceptors.response.use(
            async config => {
                const res = await this.config.responseInterceptor[0](config, this.config, this.source.cancel);
                return res;
            },
            err => {
                return this.config.responseInterceptor[1](err, this.config, this.source.cancel);
            },
        );
    }

    setConfig(option) {
        this.config = merge({}, this.config, option);
    }

    getAxiosInstance() {
        return this.instance;
    }

    sendAxios(method, url, data, config = {}) {
        const params = this.config.formatData(data);
        return new Promise((resolve, reject) => {
            if ([
                'post',
                'put',
                'patch',
            ].includes(method)) {
                this.instance[method](url, params, {
                    ...config,
                    cancelToken: this.source.token,
                }).then(res => {
                    resolve(res);
                }).catch(error => {
                    this.config.errToast(error);
                    reject(error);
                });
            } else if ([
                'get',
                'delete',
                'head',
            ].includes(method)) {
                this.instance[method](url, {
                    params,
                    cancelToken: this.source.token,
                    ...config,
                }).then(res => {
                    resolve(res);
                }).catch(error => {
                    this.config.errToast(error);
                    reject(error);
                });
            } else {
                reject(new Error('请求方法不正确!'));
            }
        });
    }
}

export default Request;
