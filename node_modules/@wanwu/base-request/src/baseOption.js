import mySentry from '@wanwu/sentry';

export default {
    base: {
        timeout: 100000,
        headers: {
            'Content-Type': 'application/json',
        },
    },
    getToken: () => sessionStorage.getItem('token'),
    tokenKey: 'Authorization',
    successCode: [
        0,
        1001,
    ],
    errToast: () => {},
    cbFor401: () => {},
    formatErr: err => err,
    formatRes: data => data,
    formatData: data => data,
    requestInterceptor: [
        (config, option, source) => {
            config.cancelToken = source.token;
            const token = option.getToken();
            const tokenKey = option.tokenKey || 'Authorization';
            if (token) {
                // 这里将token设置到headers中，header的key是token，这个key值根据你的需要进行修改即可
                config.headers[tokenKey] = token;
            }
            return config;
        },
        (err, option) => Promise.reject(option.formatErr(err)),
    ],
    responseInterceptor: [
        (response, option, cancel) => {
            const data = response.data;
            const status = response.status;
            const formatErr = option.formatErr;
            const formatRes = option.formatRes;

            const newError = {
                type: mySentry.ERROR_TYPE.Xhr,
                level: mySentry.ERROR_LEVEL.Info,
                ConfirmReport: (response.config && response.config.ConfirmReport) || null,
            };

            if (status === 200 || status === 304) {
                if (response.config.skipFilter) {
                    return data;
                } else if (data && (data.success || option.successCode.includes(data.code) || (data.status && option.successCode.includes(data.status.code)))) {
                    // 请求成功
                    // } else if (data && (data.success && data.code === 1001)) {
                    return formatRes(data);
                } else if (data && data.code === 4001) {
                    // 未登录
                    // @ts-ignore
                    // 这里的skipLogin是在请求函数中作为第三个参数传递进来的
                    if (!response.config.skipLogin) {
                        option.cbFor401(data);
                    }
                    newError.payload = data;
                    newError.message = '未登录';
                    // return new Promise((resolve, reject) => {
                    //     setTimeout(() => {
                    //         reject(formatErr(newError));
                    //     }, 3000);
                    // });
                    return Promise.reject(formatErr(newError));
                } else {
                    newError.payload = data;
                    newError.message = data.message || `服务端异常：${data.code}`;
                    return Promise.reject(formatErr(newError));
                }
            } else {
                newError.ConfirmReport = true;
                newError.extra = response;
                newError.message = response.message || response.msg || '网络异常';
                return Promise.reject(formatErr(newError));
            }
        },
        (err, option) => {
            // 对响应错误做点什么
            let msg = '';
            if (err && err.response) {
                switch (err.response.status) {
                    case 400: msg = '请求错误(400)'; break;
                    case 401: msg = '未授权，请重新登录(401)'; break;
                    case 403: msg = '拒绝访问(403)'; break;
                    case 404: msg = '未找到此接口(404)'; break;
                    case 408: msg = '请求超时(408)'; break;
                    case 500: msg = '服务器错误(500)'; break;
                    case 501: msg = '服务未实现(501)'; break;
                    case 502: msg = '网络错误(502)'; break;
                    case 503: msg = '服务不可用(503)'; break;
                    case 504: msg = '网络超时(504)'; break;
                    case 505: msg = 'HTTP版本不受支持(505)'; break;
                    default: msg = `连接出错(${err.response.status})!`;
                }
            } else {
                msg = '连接服务器失败!';
            }
            err.ConfirmReport = true;
            mySentry.logError(err);
            return Promise.reject(option.formatErr({
                ...err,
                message: err.message || msg || '请求失败',
            }));
        },
    ],
};
