var util = require("./util"), Reporter = require("./reporter"), MiniProgramLogger = function(e) {
    e && e.pid || util.warn("[arms] pid is a required prop to instatiate MiniProgramLogger");
    var t = this;
    return Reporter.call(t, e), t.appBegin = Date.now(), t._health = {
        errcount: 0,
        apisucc: 0,
        apifail: 0
    }, t.DEFAUT_PAGE_PATH = "[app]", t.isSendPerf = !1, t.beforeSend = function(e, o) {
        "error" === e ? t._health.errcount++ : "api" === e && t._health[o.success ? "apisucc" : "apifail"]++;
    }, "function" == typeof t.initHook && t.initHook(), t._conf && t._conf.behavior && "function" == typeof t.initBehavior && t.initBehavior(), 
    "function" == typeof t.autoSetCommonInfo && t.autoSetCommonInfo(), this;
};

MiniProgramLogger.prototype = util.createObject(Reporter.prototype), util.ext(Reporter._root.dftCon, {
    uid: null,
    setUsername: null,
    disableHook: !1,
    enableLinkTrace: !1,
    behavior: !1,
    enableConsole: !1,
    sendRequest: function() {},
    getCurrentPage: function() {}
}), util.ext(MiniProgramLogger.prototype, {
    constructor: MiniProgramLogger,
    _super: Reporter,
    setPage: function(e, t) {
        var o = this, n = o.prevPage;
        if (!1 !== t) {
            if (!e || e === n) return o;
            o.prevPage = e, clearTimeout(o.sendPVTimmer), o.resetPageview(), o.sendPVTimmer = setTimeout(function() {
                o.sendPV();
            }, 10);
        }
        o._conf.page = e;
    },
    onReady: function(e) {
        e();
    },
    sendRequest: function(e, t) {
        if (this.getConfig("debug")) "undefined" != typeof console && console && "function" == typeof console.log && console.log("[arms] [DEBUG MODE] log data", e); else {
            var o = this.getConfig("imgUrl");
            "object" == typeof e && (e = util.serialize(e));
            var n = o + e;
            t && (n += "&post_res=");
            var r = this._conf.sendRequest;
            if ("function" == typeof r) try {
                r(n, t);
            } catch (i) {
                util.warn("[arms] error in sendRequest", i);
            }
        }
    },
    postData: function(e, t) {
        var o = {};
        o[t] = e[t], delete e[t], this.sendRequest(e, o);
    },
    getPage: function() {
        var e = this._conf.page;
        if ("string" == typeof e && e) return util.safetyCall(e, [], e + "");
        var t = this._conf.getCurrentPage;
        if ("function" == typeof t) try {
            var o = t();
            if (o && "string" == typeof o) return o;
        } catch (n) {
            util.warn("[arms] error in getPage", n);
        }
        return "string" == typeof t && t ? t : this.DEFAUT_PAGE_PATH;
    },
    autoSetSid: function() {
        this.setCommonInfo({
            sid: util.uu()
        });
    },
    setConfig: function(e) {
        if (e && "object" == typeof e) {
            util.verifyConfig(e), e = this.setImgUrl(e);
            var t = this._conf;
            this._conf = util.ext({}, this._conf, e);
            var o = "disableHook";
            o in e && t[o] !== e[o] && (e[o] ? "function" == typeof this.removeHook && this.removeHook() : "function" == typeof this.addHook && this.addHook());
        }
    },
    appLaunch: function() {
        this.appBegin = Date.now();
    },
    pageShow: function() {
        var e = this;
        e.resetPageview(), e.sendOncePerf(), clearTimeout(e.sendPVTimmer), e.sendHealthOnPageShowOrHide(), 
        e.sendPVTimmer = setTimeout(function() {
            e.sendPV();
        }, 50), e.pvPage = e.getPage();
    },
    pageHide: function() {
        this.sendHealthOnPageShowOrHide();
    },
    addHook: function() {
        return this;
    },
    removeHook: function() {
        return this;
    },
    hookApp: function(e) {
        var t = this, o = {
            onLaunch: function() {
                var o = 1 === arguments.length ? [ arguments[0] ] : Array.apply(null, arguments), n = e.onLaunch;
                try {
                    t.appLaunch();
                } catch (r) {
                    util.warn("[arms] error in hookApp:onLaunch", r);
                }
                if ("function" == typeof n) return n.apply(this, o);
            },
            onError: function(o) {
                var n = 1 === arguments.length ? [ arguments[0] ] : Array.apply(null, arguments), r = e.onError;
                try {
                    t.error(o), t.getConfig("behavior") && "function" == typeof t.reportBehavior && t.reportBehavior();
                } catch (o) {
                    util.warn("[arms] error in hookApp:onError", o);
                }
                if ("function" == typeof r) return r.apply(this, n);
            }
        };
        return util.ext({}, e, o);
    },
    hookPage: function(e) {
        var t = this, o = {
            onShow: function() {
                var o = 1 === arguments.length ? [ arguments[0] ] : Array.apply(null, arguments), n = e.onShow;
                try {
                    t.pageShow();
                } catch (r) {
                    util.warn("[arms] error in hookPage:pageShow", r);
                }
                if ("function" == typeof n) return n.apply(this, o);
            },
            onHide: function() {
                var o = 1 === arguments.length ? [ arguments[0] ] : Array.apply(null, arguments), n = e.onHide;
                try {
                    t.pageHide();
                } catch (r) {
                    util.warn("[arms] error in hookPage:onHide", r);
                }
                if ("function" == typeof n) return n.apply(this, o);
            },
            onUnload: function() {
                var o = 1 === arguments.length ? [ arguments[0] ] : Array.apply(null, arguments), n = e.onUnload;
                try {
                    t.pageHide();
                } catch (r) {
                    util.warn("[arms] error in hookPage:onUnload", r);
                }
                if ("function" == typeof n) return n.apply(this, o);
            }
        };
        return util.ext({}, e, o);
    },
    initHook: function() {},
    autoSetCommonInfo: function() {
        this.setCommonInfo({
            app: "mini_common",
            uid: this._conf.uid
        });
    },
    sendPV: function() {
        var e = this;
        e.onReady(function() {
            e._lg("pv", {}, e.getConfig("pvSample"));
        });
    },
    sendOncePerf: function() {
        var e = this;
        e.isSendPerf || (e.onReady(function() {
            var t = {
                fpt: Date.now() - e.appBegin
            };
            e._lg("perf", t, e.getConfig("sample"));
        }), e.isSendPerf = !0);
    },
    sendHealthOnPageShowOrHide: function() {
        this.sendHealth(), this.speedCache && (this._lg("speed", this.speedCache), this.speedCache = null, 
        clearTimeout(this.speedTimmer)), this.clear(!0);
    },
    sendHealth: function() {
        if (this.pvPage) {
            var e = util.ext({}, this._health);
            e.healthy = e.errcount > 0 ? 0 : 1, e.begin = Date.now();
            var t = e.begin - this.sBegin;
            e.page = this.pvPage, e.stay = t, this._lg("health", e, 1), this._health = {
                errcount: 0,
                apisucc: 0,
                apifail: 0
            }, this.pvPage = null;
        }
    }
});

var singleton = null, generator = function(e) {
    return singleton || (singleton = new MiniProgramLogger(e || {})), singleton;
};

MiniProgramLogger.createExtraInstance = function(e) {
    e && "object" == typeof e ? (e.disableHook = !0, e.behavior = !1) : e = {
        disableHook: !0,
        behavior: !1
    };
    return new MiniProgramLogger(e);
}, MiniProgramLogger.init = generator, MiniProgramLogger.singleton = generator, 
MiniProgramLogger._super = Reporter, MiniProgramLogger._root = Reporter._root, Reporter.MiniProgramLogger = MiniProgramLogger, 
module.exports = MiniProgramLogger;